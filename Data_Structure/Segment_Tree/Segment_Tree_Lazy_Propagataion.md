# 세그먼트 트리 (Segment Tree) with range update and range query. (Lazy Propagation) 

- 관련 백준 문제 : 
  [10999번: 구간 합 구하기 2](https://www.acmicpc.net/problem/10999) ( **플레 4** )
  [17353번: 하늘에서 떨어지는 1, 2, ..., R-L+1개의 별](https://www.acmicpc.net/problem/17353) (**플레 2**) 


* 아직 Segment Tree가 뭔지 모른다면 아래의 문서를 먼저 보고 올 것!

[Segment Tree 기본편](https://github.com/MAZE-9TH-artillery-division/PS_team_note/blob/main/Data_Structure/Segment_Tree/Segment_Tree.md)


** 언제 사용할 수 있는 자료 구조인가? 

 기본편에서 다뤘던 Segment Tree의 경우 point update & range query를 지원해. 
 
 즉 합이나 최솟값 / 최댓값을 구하는 것 자체는 내가 원하는 임의의 구간에 대해서 해줄 수 있지만, 

 배열의 값을 원하는 것으로 업데이트하는 건 "한 점에 대해서만" 해줄 수 있어. 

 
 이제 Segment Tree에서 업데이트를 구간에 대해서 한다고 생각해보자. 

 (이때, 업데이트는 구간 전체에 "똑같이" 해준다고 생각하자. 예를 들면 1번째 값부터 7번째 값에 똑같이 숫자 3을 더해주는 거지)

 이걸 기본편에서 다룬 Segment Tree로 Naive하게 구현하면 아래처럼 되겠지? 

 "반복문으로 1번째 값부터 7번째 값까지 +3 업데이트를 반복" 

 이러면 시간복잡도는 원래 배열의 전체 길이가 N, 구간의 길이를 L이라 했을 때 L * O(log N) = O(L log N). 

 그런데 구간의 길이는 최대 N이니까 결과적으로는 O(N log N)이 되어버려. 


 Q. 엥 충분히 괜찮은 시간 복잡도 아닌가? 

 A. 그런데... 생각을 해보면 저럴 빠에 그냥 반복문으로 1번째 값부터 7번째 값까지 +3을 해주면서 동시에 구간 합을 계산해주는 게 더 빠르다는 것을 알 수 있어. 

    --> 이 경우 시간복잡도가 O(L) = O(N). 즉, 오히려 Segment Tree를 사용하는 게 손해인 상황이지. 

    --> 이런 상황에서 여전히 업데이트를 O(log N)의 시간 복잡도로 처리하고 싶다는 것이 우리의 소망이고, 실제로 Lazy Propagation이라는 방법을 통해 이를 구현할 수 있어. 



*** 그래서 구현은 어떻게 하는가? (이론편) 

 편의를 위해 잠시 "전체 배열의 길이가 8이고, 1번째 값부터 3번째 값까지 +3을 해준 상황"을 가정하자. 

 이때, 5번째 값부터 8번째 값을 구한다고 하면... 앞에서 +3을 해준 게 의미가 없지?

 이걸 반대로 생각하면 "1번째 값부터 3번째 값까지의 +3을 반영하지 않아도, 당장 5번째 값부터 8번째 값을 구하는 데에는 문제가 없네?"가 되는 거고, 

 이 아이디어가 

