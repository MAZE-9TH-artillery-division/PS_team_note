# 세그먼트 트리 (Segment Tree) 기본편

- 관련 백준 문제 :
    
    구간 합 구하기 (2042, 골드 1)
    
    공장 (7578, **플레 5**)
    

** 언제 사용할 수 있는 자료 구조인가? 

1. 배열의 특정 “구간”에 대한 정보를 빠르게 처리해야 할 때
2. 특히 배열의 원소들이 중간중간에 바뀔 수 있는 경우. (보통 업데이트가 이루어진다고 함)

** 주의사항 

 보통 Segment Tree를 처음 배울 때는 특정 구간 원소들의 합 / 곱을 위주로 다루다보니 

“아 구간합과 구간곱을 다뤄야 할 때 사용하면 되는구나!”라고 생각하기 쉽지만 

상상 이상으로 범용성이 뛰어난 자료 구조기 때문에, 구간의 정보를 빠르게 처리해야 하거나
업데이트가 이루어질 수 있는 상황이면 한 번 정도는 고려해보는 게 좋아! 

*** 그래서 구현은 어떻게 하는가? ( Query 처리 편 ) 

 Segment Tree는 우선 완전 이진 트리의 일종이야. 

완전 이진 트리에서 트리의 리프 노드까지 접근하는 데에 필요한 시간 복잡도는 O(log n)이라는 점을 

이용한다고 생각하면 편해. ( n : 전체 노드 개수 ) 

 다만 Segment Tree의 경우 빈 트리에서 출발해서 원소를 추가해나가지 않고, 내가 다루고자 하는 

배열을 미리 리프 노드들에 저장해놓는다는 특징을 가져. (아래 그림 참고)  

![세그먼트_트리_1.jpg](%E1%84%89%E1%85%A6%E1%84%80%E1%85%B3%E1%84%86%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20(Segment%20Tree)%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20db099fbf576647b9b7cfaae5f3b9d14f/%25EC%2584%25B8%25EA%25B7%25B8%25EB%25A8%25BC%25ED%258A%25B8_%25ED%258A%25B8%25EB%25A6%25AC_1.jpg)

 예를 들어 배열 [1, 5, 4, 1, 3]에 대한 구간 합을 저장한다고 해볼게. 

그러면 우선은 [1, 5, 4, 1, 3]을 저장해줄 수 있을 정도로 트리의 높이를 확보하고, 이후 원소들을 

리프 노드에 하나씩 순서대로 옮겨줘. 만약 길이가 2의 거듭제곱이 아니어서 공간이 남는 경우에는 
0 등의 적당한 숫자를 넣어줘. 
 (적당한 숫자는, 계산을 할 때 영향을 주지 않는 숫자를 말해. 곱셈의 경우에는 1이 들어가야겠지?) 

 이렇게 원본 배열을 잘 저장했다면 이 다음에는 부모 노드들의 값을 순서대로 계산하면 되는데, 
내 경우에는 아래 그림처럼 역순으로 (인덱스가 큰 것들부터) 채워주는 편이야.

![세그먼트_트리_2.jpg](%E1%84%89%E1%85%A6%E1%84%80%E1%85%B3%E1%84%86%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20(Segment%20Tree)%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20db099fbf576647b9b7cfaae5f3b9d14f/%25EC%2584%25B8%25EA%25B7%25B8%25EB%25A8%25BC%25ED%258A%25B8_%25ED%258A%25B8%25EB%25A6%25AC_2.jpg)

 (이렇게 하는 이유 : 자식 노드의 값들이 이미 채워진 노드들부터 계산해주어야 해서) 

 일단 여기까지 하면, Segment Tree의 초기화(Initialize)는 끝이고, 이렇게 저장해둔 트리로 어떻게
구간에 대한 정보를 처리할 수 있을지 살펴보도록 하자. 우선 가장 기본이 되는 아이디어는 아래와 같아. 

- 부모 노드에 구간에 대한 정보가 담겨 있다.

 사실 위의 아이디어만 잘 이해하면, Segment Tree의 기능들을 구현하는 것은 크게 어렵지 않아.
일단 어떤 식으로 구간에 대한 정보들이 부모 노드에 담기는지 아래 그림을 통해 살펴보자. 

![세그먼트_트리_3.jpg](%E1%84%89%E1%85%A6%E1%84%80%E1%85%B3%E1%84%86%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20(Segment%20Tree)%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20db099fbf576647b9b7cfaae5f3b9d14f/%25EC%2584%25B8%25EA%25B7%25B8%25EB%25A8%25BC%25ED%258A%25B8_%25ED%258A%25B8%25EB%25A6%25AC_3.jpg)

 위 그림에서 각 부모 노드에 표시된 숫자들은 해당 부모 노드가 가리키는 구간을 나타낸 거야. 

예를 들어서 “ 0 ~ 3 “ 이라고 표시된 노드의 값이 11인데, 이는 주어진 배열의 0번 ~ 3번 인덱스  
구간의 합이 11임을 의미해. 

 (실제로 [1, 5, 4, 1, 3]에서 1 + 5 + 4 + 1 = 11) 

 즉 Naive하게 구간합을 구할 때는 실제로 1 + 5 + 4 + 1 = 11, 총 네 개의 요소를 살펴봐야 하지만 
이처럼 미리 구간의 정보를 담고 있는 부모 노드를 이용하면 살펴봐야 하는 요소의 개수를 줄일 수 있고, 이것이 Segment Tree의 핵심 아이디어야. 

 Q. 근데 그러면 2번 ~ 4번 인덱스처럼 부모 노드 하나로 처리 못하는 구간은 어떻게 함? 

 A. 이 부분을 구현하는 게 Segment Tree에서 어려운 부분 중 하나이긴 한데, 
    일단 부모 노드를 이용해서 살펴봐야 하는 요소의 개수를 줄인다는 점은 변하지 않아. 
    
    예를 들어서 2번 ~ 4번 인덱스를 살펴본다면 이건 2번 ~ 3번과 4번으로 쪼개줄 수 있지? 
    2번 ~ 3번, 4번 모두 이미 저장을 해뒀으니까 단순히 두 노드의 값을 더해주는 것으로
   값을 구해줄 수 있어. 

   그리고 이러한 과정을 일반화하면, 다음과 같이 표현할 수 있지. 

- 구간에 포함되는 노드들을 찾아서 더해준다.
- +) 시간 복잡도를 위해, 가능한 긴 구간을 가지면서 원하는 구간에 포함되는 노드들을 찾는다.

  Q. 오…. 근데 그걸 어떻게 구현함? 

  A. 보통 Top - Down / Bottom - Up 두 가지의 방식으로 구현 방법이 나뉘는데, 여기서는 
     Bottom - Up 방식을 살펴볼게. Bottom - Up 방식은 Two pointer의 변종이라 볼 수도 있어. 

    배열은 그대로 [1, 5, 4, 1, 3]을 사용하고, 1번 ~ 4번 인덱스의 구간합을 구한다고 해보자. 

    우선 구간의 처음과 끝에 해당하는 1번 인덱스 노드와 4번 인덱스 노드를 선택하자. 

 

![세그먼트_트리_4.jpg](%E1%84%89%E1%85%A6%E1%84%80%E1%85%B3%E1%84%86%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20(Segment%20Tree)%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20db099fbf576647b9b7cfaae5f3b9d14f/%25EC%2584%25B8%25EA%25B7%25B8%25EB%25A8%25BC%25ED%258A%25B8_%25ED%258A%25B8%25EB%25A6%25AC_4.jpg)

 당연히 처음 선택한 노드들은 구간에 완전히 포함되는데, 우리는 가능하면 구간에 완전 포함되면서
최대한 긴 구간을 가리키는 노드를 선택하고 싶어. 그러면 지금 선택한 노드들의 부모 노드도 여전히 구간에 포함되는지 살펴보면 되겠지?

 *주의: 위에서 s =1, e = 4라고 적었지만 실제 트리에서의 인덱스는 s = 9, e = 13이야. 이에 대한 
           추가 설명은 나중에 실제 구현 코드와 함께 살펴볼게. 

  

 원래대로라면 완전 이진 트리니까 “현재 노드의 인덱스를 2로 나눈 몫”이 곧 부모 노드의 
인덱스인데, Segment Tree는 조금 특이한 규칙을 가져. 

 s가 (현재 s = 9) 홀수, 즉 오른쪽 자식 노드를 가리킨다고 해보자. 그러면 s의 부모 노드는
인덱스가 s보다 작은 것들도 가리키게 되어 있어. 예를 들어 현재 s = 9의 부모 노드는
0 ~ 1번 인덱스를 가리키는데, 이때 0번은 s가 가리키지 못하는 인덱스야. 

 Q. 그럼 s가 홀수일 때 s의 부모 노드는 볼 필요가 없는 건가? 

 A. ㅇㅇ. s는 처음에 우리가 원하는 범위의 가장 왼쪽을 가리켜. 
     그렇다보니 s보다 작은 인덱스를 가리킨다는 것은, 더 이상 구간에 포함될 수 없다는 뜻이야. 

     반대로 s가 짝수라면 s의 부모 노드는 s가 가리키는 인덱스 + 그보다 오른쪽의 인덱스들을 
     가리키고, 따라서 여전히 우리가 원하는 구간에 포함될 가능성이 있어. 

     정리하면 우리가 s의 값을 변화시킬 때에는, 아래의 규칙을 따라서 변화시키면 돼.  

![세그먼트_트리_5.jpg](%E1%84%89%E1%85%A6%E1%84%80%E1%85%B3%E1%84%86%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20(Segment%20Tree)%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20db099fbf576647b9b7cfaae5f3b9d14f/%25EC%2584%25B8%25EA%25B7%25B8%25EB%25A8%25BC%25ED%258A%25B8_%25ED%258A%25B8%25EB%25A6%25AC_5.jpg)

 그리고 놀랍게도, 이 연산은 별도의 if문없이 s = (s + 1) // 2 라는 한 줄 코드로 해결할 수 있어. 

 Q. 아 ㄹㅇ? 그럼 그냥 저걸로 끝이야? 

 A. ㄴㄴ. s가 홀수 일 때는 처리 하나를 더 해줘야 해. 
     s가 홀수일 때 s = (s + 1) // 2를 실행하고 나면 (파란색 화살표 참고)
    새로운 s는 더 이상 기존 범위를 가리키지 못하거든. 
    그래서 s가 홀수일 때에는 현재 노드의 값을 계산에 반영을 해준 뒤 s = (s + 1) // 2를 실행해야 해. 

 Q. 계산에 반영한다는 게 무슨 소리일까요..? 

 A. 지금의 경우에는 구간합을 구하고 싶었던 것이니까, 나중에 출력해주고 싶은 정답 값에 그만큼 
    더해주면 돼 ㅇㅇ. 말로만 더 설명하면 오히려 복잡해질 수 있으니 실제 코드의 일부를 살펴보자. 

```python
#마지막에 정답으로써 출력해주고자 하는 변수: summation 

if(s % 2 == 1): 
	summation += seg_tree[s] 
if(e % 2 == 0):
	summation += seg_tree[e] 

s = (s + 1) // 2
e = (e - 1) // 2
```

 참고로 위 코드에는 e에 대한 내용도 포함되어 있는데, e의 경우 상황이 대칭적으로 바뀐다는 것만 
생각해주면 비교적 쉽게 이해할 수 있을 거야. 위 코드를 반복해서 실행하는 과정을 그림으로 
표현해보면, 아래와 같이 나타낼 수 있어. 

![세그먼트_트리_6.jpg](%E1%84%89%E1%85%A6%E1%84%80%E1%85%B3%E1%84%86%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20(Segment%20Tree)%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20db099fbf576647b9b7cfaae5f3b9d14f/%25EC%2584%25B8%25EA%25B7%25B8%25EB%25A8%25BC%25ED%258A%25B8_%25ED%258A%25B8%25EB%25A6%25AC_6.jpg)

(보라색 체크 표시는 합을 반영해주는 부분. 즉, 보라색 체크 표시가 된 값들을 다 더하면 답이 돼.) 

 즉 s = (s + 1) // 2은 마저 살펴보고자 하는 범위를 계속 오른쪽으로 옮기고, 반대로 e = (e - 1) // 2는 
살펴보고자 하는 범위를 계속 왼쪽으로 옮긴다고 이해할 수도 있어. 

 그러다보면 언젠가는 서로 크로스되면서 s가 e보다 큰 상황이 생길텐데, 그때에는 반복문을 
중단해주면 되겠지? 정리하면 아래와 같은 코드를 얻을 수 있어.

```python
#마지막에 정답으로써 출력해주고자 하는 변수: summation 
summation = 0 
while(s <= e):
	if(s % 2 == 1): 
		summation += seg_tree[s] 
	if(e % 2 == 0):
		summation += seg_tree[e] 
	
	s = (s + 1) // 2
	e = (e - 1) // 2
```

 여기까지 이해가 됐다면, 이제는 Segment Tree의 꽃인 Update 부분을 구현해보자. 

*** 그래서 구현은 어떻게 하는가? ( Update 편 ) 

 사실 Update의 구체적인 코드는 내가 어떤 연산을 해야 하는지에 따라서 조금씩 달라지지만, 
원리 자체는 비슷비슷하니 우선은 구간 합을 구할 때의 Update를 구현해보자. 

 위 예시의 [1, 5, 4, 1, 3]의 4를 7로 Update해준다고 생각해보자. 이때 그림에서 값을 바꿔줘야 하는노드들을 표시해보면 아래와 같아. 

![세그먼트_트리_7.jpg](%E1%84%89%E1%85%A6%E1%84%80%E1%85%B3%E1%84%86%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20(Segment%20Tree)%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20db099fbf576647b9b7cfaae5f3b9d14f/%25EC%2584%25B8%25EA%25B7%25B8%25EB%25A8%25BC%25ED%258A%25B8_%25ED%258A%25B8%25EB%25A6%25AC_7.jpg)

 위 그림을 살펴보면 구간 합의 경우에는 그냥 자기 자신부터 출발해서 부모 노드들만 계속 Update 해주면 된다는 사실을 알 수 있어. 완전 이진 트리였으니까 자기 자신의 인덱스를 계속 2로 나눠주면
되겠지? 이걸 코드로 표현하면 아래와 같아. 

```python
def update(idx, value): 
	#seg_tree[idx]를 value로 업데이트.
	delta = value - seg_tree[idx]
	
	while(idx > 0): 
		#구현 방식에 따라 조건문 자체는 약간 달라질 수도 있음. 
		seg_tree[idx] += delta 
		idx = idx // 2 
```

 이러고 나면 Update가 이루어져도 여전히 기존과 같은 방식으로 구간합을 구해줄 수가 있고,
이처럼 Update가 일어나는 상황에서도 편하고 빠르게 정답을 구해주는 자료 구조가 
바로 Segment Tree라고 할 수 있어. 

 Q. Segment Tree의 꽃인거 치고는 상당히 간단한데? 

 A. 그건 구간합이 가장 간단한 예시여서 그래. 
    이 Update 과정을 잘 개조(?)하면 나중에는 Update가 한 요소에 대해서가 아니라 
    어느 구간에 대해서 일어난다해도 빠르게 처리할 수 있는데, 이런 식으로 
    변형을 가하다보면 코드가 꽤 복잡해지니 너무 간단하다고 방심하지 말 것. 

   (업데이트가 구간 단위로 이루어지는 경우에도 빠르게 처리할 수 있도록 할 때에는 보통 
    Lazy Propagation이라는 기법을 이용하는 데, 이건 나중에 다른 문서에서 다룰게.) 

   그리고 사실 Update를 Segment Tree의 꽃이라고 부른 이유는 구현이나 개념이 어려워서가 아니라
   Segment Tree가 갖는 다른 자료 구조와의 가장 큰 차별점이기 때문이야. 

*** 시간 복잡도 
 Query 처리와 Update 모두 Segment Tree의 높이에 비례하는 시간 복잡도를 갖고, Segment Tree의 높이는 log 2n에 비례하니 

Query 처리와 Update 모두 시간복잡도가 O(log n)이라고 할 수 있어. 

 - 예제 풀이 : [2042번: 구간 합 구하기 (acmicpc.net)](https://www.acmicpc.net/problem/2042) ( 티어 : 골드 1 ) 

![세그먼트_트리_예제.JPG](%E1%84%89%E1%85%A6%E1%84%80%E1%85%B3%E1%84%86%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20(Segment%20Tree)%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20db099fbf576647b9b7cfaae5f3b9d14f/%25EC%2584%25B8%25EA%25B7%25B8%25EB%25A8%25BC%25ED%258A%25B8_%25ED%258A%25B8%25EB%25A6%25AC_%25EC%2598%2588%25EC%25A0%259C.jpg)

 중간에 수의 변경이 일어나지 않는다면, 사실 이 문제는 누적 합(Prefix Sum)으로 상당히 쉽게 
풀리는 문제야. 전처리를 할 때 O(n), 이후 각 Query를 처리할 때 O(1)이라서 상당히 빠르거든. 

 하지만 중간에 업데이트가 일어나면 전처리로 만들어둔 배열을 다시 O(n)의 시간 복잡도로 
수정해야 하고, 이렇다보니 문제에서 요구하는 시간제한을 맞출 수가 없게 돼. 

 따라서 이 문제를 해결하기 위해서는…

- 구간 합을 적절하게 다룰 수 있는 자료 구조
- 업데이트를 적절한 시간 내에 처리해줄 수 있는 자료 구조

위 두 가지를 만족하는 자료 구조를 구현해야 하고, 이때 대표적인 자료 구조가 Segment Tree야. 

이제 입력을 보면서 Segment Tree를 구현해보자. 

![세그먼트_트리_예제_2.JPG](%E1%84%89%E1%85%A6%E1%84%80%E1%85%B3%E1%84%86%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20(Segment%20Tree)%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%E1%84%91%E1%85%A7%E1%86%AB%20db099fbf576647b9b7cfaae5f3b9d14f/%25EC%2584%25B8%25EA%25B7%25B8%25EB%25A8%25BC%25ED%258A%25B8_%25ED%258A%25B8%25EB%25A6%25AC_%25EC%2598%2588%25EC%25A0%259C_2.jpg)

 < 풀이 코드 및 주석 설명 > 

```python
import sys 
input = sys.stdin.readline 

n, m, k = map(int, input().split(' ')) 

# 일단 리프 노드에 n개의 숫자를 옮겨야 하니
# 리프 노드들이 n개 이상이 되는 최소한의 높이를 구하자. 
j = 0 
while(2 ** j < n): # 깊이가 j인 노드들의 개수는 2 ^ j 개. 
	j += 1 

cst = 2 ** j #이 숫자는 앞으로 자주 쓸 예정이기 때문에, 저장해주도록 하자. 
seg_tree = [0 for _ in range(2 * cst)]
# 참고로 리프 노드들의 개수가 2 ** j면 
# 전체 노드의 개수는 
# 1 + 2 + 2 ** 2 + 2 ** 3 + ... + 2 ** j = 2 ** (j + 1) = 2 * (2 ** j) = 2 * cst - 1
# (증명은 등비수열의 합 공식으로 가능)  
# 따라서 이때 인덱스 0을 더미용으로 추가해주면 seg_tree의 길이는 2 * cst. 
# 즉, 루트 노드의 인덱스는 1

for i in range(0, n, 1): 
	seg_tree[i + cst] = int(input()) 
# 마지막 층을 제외한 노드들의 개수는 1 + 2 + 2 ** 2 + ... + 2 ** (j - 1) = 2 ** j - 1 = cst - 1. 
# 따라서 인덱스 cst ~ 2 * cst - 1까지가 segment tree의 리프 노드들이야! 
# (인덱스 0을 비워놨다는 것에 조심)

# 이제 부모노드들의 값을 채워주자. 
idx = n - 1 + cst
while(idx > 1): 
	seg_tree[idx // 2] += seg_tree[idx] 
	idx -= 1 
#위 코드는 idx를 자식 노드의 인덱스라고 생각하고 구현한 것. 
#idx를 부모 노드의 인덱스라고 생각하면 idx의 초기값이 약간 달라지고 
#seg_tree[idx] = seg_tree[2 * idx] + seg_tree[2 * idx + 1]로 바꿔주어야 해. 

#여기까지 하면, 딱 초기화까지 진행한 거야! 

#이제 Query 함수와 Update 함수를 구현해보자. 
def query(b, c): #b번째 원소부터 c번째 원소까지의 합을 구하는 함수. 
	s = b - 1 + cst
	e = c - 1 + cst 
	#주어진 b와 c를 segment tree의 리프 노드 인덱스로 변경해주자. 
	
	summation = 0 
	while(s <= e): 
		if(s % 2 == 1): 
			summation += seg_tree[s] 
		if(e % 2 == 0): #여기 else로 적지 않도록 조심! 
			summation += seg_tree[e] 
		s = (s + 1) // 2 
		e = (e - 1) // 2 
	
	print(summation) 
	return 
	

def update(b, c): #b번째 수를 c로 update해주는 함수. 
	idx = b - 1 + cst 
	delta = c - seg_tree[idx] 
	
	while(idx > 0): 
		seg_tree[idx] += delta 
		idx = idx // 2 
	
	return 
	
#이제 남은 일은 정답을 출력해주는 일 뿐. 

for _ in range(m + k): 
	a, b, c = map(int, input().split(' ')) 
	
	if(a == 1): 
		update(b, c) 
	else: 
		query(b, c) 
```

** 여담 

 Segment Tree는 정말 활용이 다양하니까 자주 사용되는 활용 / 풀어보면 좋은 문제들은 앞으로도

자주 올릴 거고, 잘 모르는 게 있을 때마다 열심히 공부해보도록 하자!