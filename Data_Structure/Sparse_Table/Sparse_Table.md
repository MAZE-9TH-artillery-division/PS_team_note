# 희소 배열 (Sparse Table)

- 관련 백준 문제
    - 합성함수와 쿼리 (17435, 골드 1)
    - 도로 네트워크 (3176, **플레 4**)

** 언제 사용할 수 있는 자료 구조인가? 
 
 인터넷에 검색을 해보면 다양한 예시가 있지만 그 예시들을 포괄할 수 있도록 설명해보자면 

”어떤 절차를 k번 거친 결과를 빠르게 구하고 싶을 때” 사용할 수 있는 자료 구조야. 

![Untitled](%E1%84%92%E1%85%B4%E1%84%89%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%20(Sparse%20Table)%20fb6735398d9646119e43b575813172d1/Untitled.png)

(출처 : [🧩 [Algorithm] 희소 배열(Sparse Table) 알고리즘 | hello-capo!](https://hello-capo.netlify.app/algorithm-sparse-table/) ) 

 위처럼 다음으로 이동할 수 있는 정점이 단 하나씩만 존재하는 그래프에서 k번 이동한 후에 위치한 정점을 구할 때 사용할 수도 있고,   (cf. 위와 같은 그래프를 functional graph라고 해!) 

![Untitled](%E1%84%92%E1%85%B4%E1%84%89%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%20(Sparse%20Table)%20fb6735398d9646119e43b575813172d1/Untitled%201.png)

 위 그림처럼  특정 함수 f를 k번 합성한 함수에 x를 넣은 값을 계산해야할 때도 사용할 수 있어! 

(사실 잘 생각해보면 위의 두 상황은 근본적으로 동일한 상황임을 알 수 있기도 해) 

 Q. 근데 위 상황들은 그냥 for문으로 해결할 수 있지 않나? 

 A. ㅇㅇ. Naive하게 단순 for문으로 구현해도 O(n)으로 풀리긴 해. 

     다만 우리의 목표는 위 문제를 조금 더 빠른 O(log n)의 시간 복잡도로 해결해보는 거야! 

** 그래서 어떻게 구현하는가? (이론편) 

 사실 Sparse Table은 구현보다는 아이디어가 상당히 중요하고, 실제로 아이디어를 알고 나면 구현
자체는 그렇게 어렵지 않아. 

(실제로 난이도가 좀 있는 문제들을 풀 때에도 구현보다는 아이디어를 활용하는 부분이 힘들어…)

 아이디어를 활용하는 것들은 다른 문서들에서 차차 다뤄보도록 하고, 우선은 가장 기본적인 
문제인 위의 예시 (k번 전진하기 / f를 k번 합성한 뒤의 값 구하기)에서의 아이디어를 살펴보자. 

 < Naive한 아이디어 > 
 그냥 for문으로 k번 전진을 구현한다. 즉, 한 칸씩 k번을 전진한다. —> O(k)의 시간 복잡도. 

 < Sparse Table의 아이디어 > 

 2 ^ i 칸 씩 전진하자. 이때 i는, 최대한 큰 값을 유지해주도록 하자. 

예를 들어 k = 42라면 … 

 k = 32 + 8 + 2  —> 단 세 번의 전진 ( i = 5, 3, 1 )만으로 동일한 효과를 낼 수 있다! 

+) 다만 2 ^ i 칸 씩 전진한 결과를 맨날 계산해주어야 한다면, 위 아이디어를 적용하는 의미가 
    없으니 이 부분은 Dynamic Programming을 이용하자! 

—> 이러면 최종적으로는 O(log k)의 시간 복잡도로 문제를 해결 할 수 있어. (전처리 제외) 
      왜 O(log k)가 되는지도 차근차근 살펴볼 것이니 너무 걱정은 하지 말고! 

 단순히 말로만 하면 구현이 쉽지 않으니 우선 예제를 살펴보자. 
( [17435번: 합성함수와 쿼리 (acmicpc.net)](https://www.acmicpc.net/problem/17435) )

![Untitled](%E1%84%92%E1%85%B4%E1%84%89%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%20(Sparse%20Table)%20fb6735398d9646119e43b575813172d1/Untitled%202.png)

( 글자가 잘 안보이면 우클릭 - 원본 보기를 하거나 직접 문제 링크로 들어갈 것. ) 

 사실 위에서 들었던 함수 예시는 정확히 이 문제에서 가져온 거야. 제한을 신경쓰지 않고 단순한 
반복문이나 재귀함수로 쉽게 구현해도 답 자체는 구할 수 있지만, 그럴 경우에는 시간이 꽤 걸린다는 단점이 있어. 

 ( 각 쿼리마다 n이 최대로 주어지는 상황을 가정하면 200,000 * 500,000 = 100,000,000,000 번의 계산을 해야하는 데, 이건 O(n)의 시간 복잡도로 처리해도 시간 제한 1초를 맞춰주기가 힘들어…) 

 그래서 미리 2 ^ i번을 대입해서 계산한 결과를 저장해놓고, 이를 이용해서 각 쿼리마다 O(log n)의 
시간 복잡도로 처리해주는 것이 이 문제에서 Sparse Table을 사용하는 아이디어라고 할 수 있지. 

< 구현 1 - 전처리 과정 > 

 Sparse Table을 채우는 과정은 Dynamic Programming을 이용하기 때문에 우선 Sparse Table을 
선언하고, 초기값들을 채워넣어야 해.

 여기서 말하는 초기값은 보통 2 ^ i에서 i = 0인 경우, 즉 이 문제에서는 함수에 x를 단 한 번만 
대입한 경우를 의미해. ( cf. 2 ^ 0 = 1 )

 보통 그래프 관련 문제에서는 내가 직접 BFS / DFS를 이용해서 i = 0인 경우들을 구하고 채워주어야 하지만, 이 문제에서는 f(1) , f(2) , … , f(m)을 알려주니까 이 값들을 입력받고 그대로 사용하면 돼!

```python
import sys 
input = sys.stdin.readline 

m = int(input()) 
inform = [0] + list(map(int, input().split(' '))) 
# 사용하고자 하는 인덱스가 1 ~ m이라서 위처럼 입력을 받고.. 

#이제 sparse table 선언을 해주자. 
k = 0 
while(2 ** k <= 500000): # n의 범위가 500,000까지
	k += 1 
sparse = [[0 for _ in range(m + 1)] for _ in range(k)] 
# sparse[i][j] = j를 함수 f에 2 ^ i번 대입해준 값 

for i in range(1, m + 1, 1): 
	sparse[0][i] = inform[i] #즉, 여기는 함수 f에 1번씩 대입해준 값을 저장해주는 것. 
```

 사실 C / C++로 문제를 푼다면, 위 코드에서 while문으로 k += 1 을 반복하는 부분은 필요하지 않아. 
대신 주어진 n의 범위인 500,000에 대해 “적합한” k값을 미리 구해준 뒤 정적 배열 선언에 사용하면
충분해. (아니면 그냥 vector 등을 사용해서 위처럼 해도 되고) 
 
+) 여기서 말하는 “적합한” k값은, 2 ^ k의 값이 500,000보다는 작거나 같은 최대의 k값을 의미해. 
    적합한 k값보다 큰 값은 애초에 사용할 일이 없으니 메모리만 더 잡아먹겠지? 

 Q. 근데 while 조건문을 저렇게 짜면 n의 범위가 64 = 2 ^ 6처럼 주어질 때는 k값이 7이 되지 않나? 

 A. 아 ㅇㅇ 맞아. 근데 그 밑에 sparse 부분을 자세히 보면 for _ in range(k)로 작성되어 있지? 
    그래서 실제로 만들어지는 sparse table은 우리가 의도한 대로 만들어져. 

   —> range(k)에 의해 만들어지는 인덱스는 0 , 1 , 2 , … , k - 1인데, 이것들이 각각 
         2 ^ 0 , 2 ^ 1 , 2 ^ 2 , … , 2 ^ (k - 1)을 나타내기 때문이야! 약간 일부러 k값을 1만큼 더 크게 
         잡았다고 생각해도 좋고, 사실 논리만 맞다면 위 코드는 마음대로 변형해도 전혀 상관이 없어! 

< 구현 2 - Dynamic Programming으로 값 채우기 > 

 이 부분이 가장 핵심인데, 우선 아래의 말을 이해해보자. 
(편의상 함수에 대입하는 거 대신 k번 전진하는 예시를 다시 사용할게. )

- 2 ^ (k - 1)번 전진하고, 다시 2 ^ (k - 1)번 전진하면 2 ^ k번 전진한 것과 마찬가지이다.

![Untitled](%E1%84%92%E1%85%B4%E1%84%89%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%20(Sparse%20Table)%20fb6735398d9646119e43b575813172d1/Untitled%203.png)

 말로 이해해도 좋고, 위의 간단한 수식을 이용해서 이해해도 상관은 없어. 

우선 위의 사실을 어떻게든 이해했다면, sparse[ i ][ j ]  = ( j를 2 ^ i 번 대입한 값 ) 이었으니 

아래의 점화식을 유도할 수 있어. 

![Untitled](%E1%84%92%E1%85%B4%E1%84%89%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%20(Sparse%20Table)%20fb6735398d9646119e43b575813172d1/Untitled%204.png)

- 2 ^ i 번 전진 (대입) = 2 ^ ( i - 1 ) 번 전진 (대입)하고, 다시 2 ^ ( i - 1 ) 번 전진.

 이미 2 ^ ( i - 1 )번 전진한 결과가 sparse[ i - 1 ][ j ]에 저장되어 있을테니, 그 저장된 값을 
2 ^ (i - 1) 번 전진시키겠다는 것으로 이해할 수 있고, 이렇게 하면 sparse 배열의 나머지 부분들을 
채워줄 수 있어!

```python
for i in range(1, k, 1): 
	for j in range(1, m + 1, 1): 
		sparse[i][j] = sparse[i - 1][sparse[i - 1][j]] 
```

< 구현 3 - 만들어둔 Sparse Table로 쿼리 처리해주기 > 

 Sparse Table까지 만들었다면, 실제로 원하는 값을 구하는 쿼리 부분은 쉽게 구현할 수 있어. 

아이디어 부분에서 설명했던 42 = 32 + 8 + 2 예시 기억 나? 이 에시를 그대로 구현해주면 돼. 
얘는 말로 설명하는 것보다 코드를 보는 것이 쉬우니, 곧바로 코드를 보자 ㅇㅇ. 

```python
q = int(input()) #내가 처리해주어야 하는 쿼리의 수 

for _ in range(q): 
	n, x = map(int, input().split(' ')) # x를 n번 대입한 값을 구해주어야 함. 
	
	i = k - 1 # 내가 한 번에 전진할 수 있는 칸 수는 2 ^ (k - 1)칸.
	 
	while(n > 0): 
		while(2 ** i > n): # 남아 있는 n에 대해서, 내가 얼마나 전진할 수 있는지를 계산 
			i -= 1 
		x = sparse[i][x] # 얼마나 전진할 수 있는지를 계산했다면, 그만큼 전진시켜준다. 
		n -= 2 ** i # 전진한 칸 수만큼 n값을 빼준다. n == 0 --> 더 이상 전진할 필요 X. 
	
	print(x) #구한 결과값 출력. 
```

 이렇게까지 해주면 문제는 다 풀었고, 코드를 모두 합치면 아래와 같아! 

```python
import sys 
input = sys.stdin.readline 

m = int(input()) 
inform = [0] + list(map(int, input().split(' '))) 
# 사용하고자 하는 인덱스가 1 ~ m이라서 위처럼 입력을 받고.. 

#이제 sparse table 선언을 해주자. 
k = 0 
while(2 ** k <= 500000): # n의 범위가 500,000까지
	k += 1 
sparse = [[0 for _ in range(m + 1)] for _ in range(k)] 
# sparse[i][j] = j를 함수 f에 2 ^ i번 대입해준 값 

for i in range(1, m + 1, 1): 
	sparse[0][i] = inform[i] #즉, 여기는 함수 f에 1번씩 대입해준 값을 저장해주는 것. 
	
for i in range(1, k, 1): 
	for j in range(1, m + 1, 1): 
		sparse[i][j] = sparse[i - 1][sparse[i - 1][j]] 

q = int(input()) #내가 처리해주어야 하는 쿼리의 수 

for _ in range(q): 
	n, x = map(int, input().split(' ')) # x를 n번 대입한 값을 구해주어야 함. 
	
	i = k - 1 # 내가 한 번에 전진할 수 있는 칸 수는 2 ^ (k - 1)칸.
	 
	while(n > 0): 
		while(2 ** i > n): # 남아 있는 n에 대해서, 내가 얼마나 전진할 수 있는지를 계산 
			i -= 1 
		x = sparse[i][x] # 얼마나 전진할 수 있는지를 계산했다면, 그만큼 전진시켜준다. 
		n -= 2 ** i # 전진한 칸 수만큼 n값을 빼준다. n == 0 --> 더 이상 전진할 필요 X. 
	
	print(x) #구한 결과값 출력. 
```

*** 쿼리를 처리할 때의 시간 복잡도

 위 문제의 쿼리에서 숫자 31이 들어왔다고 해보자. 

31 = 11111 (2) 니까, 우리가 실제로 x = sparse[ i ][ x ]를 실행해주는 횟수는 5번이 되겠지? 
( 11111 → 01111 → 00111 → 00011 → 00001 → 00000 ) 

 그러면 이때, “이진수로 나타냈을 때 1의 개수가 매우 적으면 상관없지 않을까?”라고 
생각해볼 수 있는데, 아래 그림을 살펴보면 사실 1의 개수가 매우 적어도 반복문의 반복 횟수는 거의 
그대로임을 알 수 있어. 

![1.jpg](%E1%84%92%E1%85%B4%E1%84%89%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%20(Sparse%20Table)%20fb6735398d9646119e43b575813172d1/1.jpg)

( 결국 i = 4 → 3 → 2 → 1 → 0으로 만들기 위한 반복 횟수가 필요해졌음. )

 

 즉, 중간에 곧바로 n이 0이 되어서 반복문이 끝나는 게 아니라면 결국 반복문의 반복 횟수는 
”주어진 n을 이진수로 나타내었을 때의 자릿수”에 비례하게 되고, 

 위 사실과 고등학교 때 배웠던 로그 관련 내용 혹은 등비수열의 합 등을 이용하면 시간복잡도가 
O( log n )임을 알 수 있어! 
 

+)
 참고로 위 그림에서처럼 이진수로 나타내었을 때 값이 1인 첫 번째 자리를 구하는 과정은 

보통 일반적인 반복문을 통해 해결하긴 하는데, 이분 탐색을 이용하면 시간 복잡도에 

로그를 한 번 더 씌워줄 수도 있어! 아니면 관련 내장 함수가 C++에는 존재하니 찾아보는 것도 

좋을 거 같아! 

++) 
  사실 시간 복잡도를 위에서는 O( log n )이라고 했는데, 내가 코드를 특이하게 작성하다보니 

실제로 내 코드의 시간 복잡도는 O( log n )이라고 보기 어려워. 

```python
i = k - 1 
	while(n > 0): 
		while(2 ** i > n): 
			i -= 1 
		x = sparse[i][x]
		n -= 2 ** i 
```

 위 코드를 처음 실행하면 우선 2 ** i ≤ n이 될 때까지 i의 값을 하나씩 줄이는데, 이 과정의 
시간 복잡도가 O( log n )이 아니기 때문이야.  (오히려 n이 클수록 반복 횟수가 줄어들어!) 

 만약 확실하게 O( log n )이라고 보장받고 싶다면, 처음에 i의 값을 0으로 놓고 2 ** i > n일 때까지 
i의 값을 하나씩 늘려가는 방식으로 바꾸면 돼.