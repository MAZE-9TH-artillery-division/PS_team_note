# 위상 정렬 (Topological Sort)

* 참고: 

 이름은 위상 “정렬”이지만 특이하게도 그래프가 있어야만 사용가능한 정렬이어서 일단은 그래프로 분류했어! 

- 관련 백준 문제: 
2252 (줄 세우기) : 골드3 / 1516 (게임 개발하기) : 골드3 / 1948 (임계경로) : 플래티넘5

** 언제 사용할 수 있는 알고리즘인가? 

 우리가 스타크래프트를 할 때 몇몇 건물의 경우에는 미리 특정 건물을 설치한 상태여야 지을 수 있는 건물들이 있어. ( 예시: 저그의 경우 sunken colony를 만들려면 Spawning pool을 지어야 함)  

이런 것을 약간 일반화하면, A를 한 뒤에 B를 할 수 있다고 정리할 수 있고, 나아가서 우리가 다루는 그래프에서는 “node A를 방문한 뒤에 node B를 방문할 수 있다”라고 정리할 수 있지. 

 그래서 위상 정렬은 “유향 그래프(Directed Graph)에서 node들을 정렬해주고 싶을 때” 사용해주는 정렬 알고리즘. 다만 조금 더 정확히는, “사이클이 존재하지 않는 유향 그래프 (Directed Acyclic Graph)”에서 사용 가능해! 

 (쉽게 생각하자. A → B → C → A라는 사이클이 생겨버리면 C가 앞에 올지, A가 앞에 올지 결정하기가 애매해져버려.)  

*** 그래서 구현은 어떻게 하는가? 

(참고 문헌: Codeground Note [Practice | codeground](https://www.codeground.org/practice) / Do it 알고리즘 코딩테스트 파이썬편) 

 기본 원리들은 전부 비슷비슷한데, 쉽게 생각하자면 DFS / BFS를 가볍게 변형한다고 보면 될 듯! 

< 인접 리스트 방식 > 

—> 이때에는 각 node의 인접 리스트를 모든 node에 대해 만들어두고, “각 node에서 자신에게로 들어오는 간선” (incoming edge라고도 해)의 개수를 저장해. 

 예를 들어서, node가 총 3개가 있고 1 → 3, 2 → 3을 입력 받았다면 node 3의 인접 리스트는 

[1, 2]가 되는거지. (1번 node, 2번 node)  

 그러면 이 인접 리스트는 어떻게 활용하냐? 

우선 인접 리스트와 별개로 진입 차수 리스트를 만들어. (예를 들어 위의 상황에서는 [0, 0, 2])

그러면 이제 진입 차수가 0인 것. 즉, “더 이상 다른 곳을 방문할 필요가 없는 곳”을 먼저 방문해주는 거야. 

(cf. 진입 차수는 쉽게 생각하면 incoming edge의 합이야!) 

 이때 특정 node를 방문할 때에는, 인접 리스트를 돌면서 해당 node들의 진입 차수를 1씩 빼주고, 이때 진입 차수가 0이 된 node가 있다면 방문 리스트에 넣어줘. 이러한 과정을 반복해주면 끝! 

말로만 하면 이해하기 어려울 수 있으니 (완벽하지는 않지만) 예제 코드를 보자. 

[줄 세우기 (위상 정렬).ipynb](%E1%84%8B%E1%85%B1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20(Topological%20Sort)%209f8c93f63600447a877aaf3d9ab38b2b/%25EC%25A4%2584_%25EC%2584%25B8%25EC%259A%25B0%25EA%25B8%25B0_(%25EC%259C%2584%25EC%2583%2581_%25EC%25A0%2595%25EB%25A0%25AC).ipynb)

![Untitled](%E1%84%8B%E1%85%B1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20(Topological%20Sort)%209f8c93f63600447a877aaf3d9ab38b2b/Untitled.png)

![Untitled](%E1%84%8B%E1%85%B1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20(Topological%20Sort)%209f8c93f63600447a877aaf3d9ab38b2b/Untitled%201.png)

(사진이 잘 안보일 경우 우클릭 - 원본 사진 보기) 

 위는 내가 작성한 백준 2252 줄 세우기 문제 해결 코드야.

입력은 A B (A학생이 B학생 앞에 위치해야 한다는 뜻) 형식인데, 그렇다면 A를 일종의 부모 노드, B를 자식 노드로 볼 수 있지? 

 그래서 Node 클래스에서 parent, child를 기본적으로 선언해주고 입력받을 때 자식 노드의 parent를 1씩 늘려주는 방식을 사용했어. (먼저 줄 세워야 하는 학생의 수를 저장한 셈이지) 
(child의 경우에는 dict을 이용하긴 했는데 사실 인접 리스트랑 별 다를바 X) 

 이후에는 bfs를 돌렸는데, 일단 parent가 0인 (먼저 다른 학생을 줄 세울 필요가 없는 학생들) node들을 먼저 queue에 넣어준 뒤, 
 queue에서 뽑은 node의 자식들을 반복문으로 돌면서 parent -= 1을 해줬어. queue에서 뽑았다는 것을 줄을 세웠다는 것으로 간주한 거지. 이러면 이제 parent가 0이 된 학생들은 다시 queue에 넣는 방식으로 bfs를 계속 돌릴 수 있고 이게 곧 위상정렬이 돼. 

Q. bfs에서 중간에 Node(i)를 queue에 그냥 append 하는 코드가 있는데 그건 왜? 

A. 문제에서 모든 학생에 대한 입력을 준다는 보장이 없어서, 입력이 들어오지 않은 학생은 일단 먼저 줄을 세워버리는 방식을 채택했어. (실제로 저 코드가 없으면 오답이야!) 

**** 주의 사항이나 시간복잡도? 

 1. 기본적으로 사이클이 없을 때만 사용 가능하다. 

 2. 위상 정렬은 꼭 유일한 결과를 내놓지 않아! 어떻게 입력을 처리하냐에 따라서 같은 입력도 
     다른 결과로 이어질 수 있어! —> 가장 핵심적인 내용. 

    (쉽게 생각하자면, A → C라고 했을 때 A → B → D → C이든 A → D → C이든 일단 A가 C보다
     앞에 있기만 하면 되는 정렬 방식이야!) 

 3. 시간복잡도는 기본적으로 DFS / BFS의 시간복잡도인 O(V + E) (V: node 개수, E: edge 개수) .