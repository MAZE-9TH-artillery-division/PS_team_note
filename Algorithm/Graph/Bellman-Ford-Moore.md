# 벨만 - 포드 (Bellman - Ford - Moore) 알고리즘

- 관련 백준 문제: 
타임머신 (11657, 골드 4) / 오민식의 고민 (1219, **플레 5**)

** 언제 사용할 수 있는 알고리즘인가? 

1. 그래프의 “한 node”에서 “다른 모든 node”로의 최단 거리를 구할 때 
2. 그래프에 가중치가 “음수”인 edge가 존재할 때도 사용 가능 
3. 한편, 이 알고리즘에는 다른 용도가 하나 더 있는데 그것은 아래의 설명들 참고

<다익스트라 (dijkstra) 알고리즘과의 비교> 

1번 사항은 서로 동일. 

다만, dijkstra의 경우 그래프의 가중치들이 “모두 0 이상”일 때에만 사용 가능 

벨만 - 포드 알고리즘의 주된 다른 용도를 dijkstra 알고리즘은 포함하지 않음.

*** 그래서 구현은 어떻게 하는가?  (이론편) 

 우선 node가 N개인 그래프가 주어졌다고 생각해보자. 만약 모든 edge의 가중치가 양수라면, 임의의 node A, B를 골랐을 때, 이 둘을 이어주는 최단 경로는 해봤자 N - 1개의 edge만을 가질 수 있을 거야. 
왜냐하면 모든 node가 각각 한 edge로만 연결 되어 있고 A, B가 양 끝점 일때 (아래 그림 참고) 정확히 N - 1개의 edge로 A, B를 잇게 되고, 모든 가중치가 양수면 edge의 개수가 더 많다 —> 거리가 더 멀거나 같다가 성립하거든! 

![1.jpg](%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB%20-%20%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20(Bellman%20-%20Ford%20-%20Moore)%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20101ba57435d741c89c10a35a0fd02614/1.jpg)

(맨 왼쪽의 보라색 node를 A, 맨 오른쪽의 것을 B라 하면 정확히 하얀 선 4개로 둘이 이어지는 것을 알 수 있어!) 

 여기서 벨만 - 포드 알고리즘의 핵심 및 과정은 아래와 같아. 

  0. 미리 우리가 출발하고자 하는 node에 대해서는 최단거리를 0 등의 적당한 초기값으로 설정.
      (이 초기값은 무한대보다 작도록 설정!) 다른 node들에 대해서는, 최단거리를 float(’inf’) 처럼 
     무한대 or 아주 큰 값으로   

1. Edge들을 저장해놓은 리스트 (혹은 적당한 자료구조)를 돌면서 차츰차츰 최단거리를 갱신. 
이때, 내가 고른 node의 최단거리가 아직 갱신이 안된 상태라면 (즉, 무한대라면) 
그냥 다음 Edge로 넘어가! 
2. 추후 더 설명하겠지만 위의 1번 과정은 노드의 총 개수를 N이라 할 때 정확히 N - 1번 반복. 

      (이것이 위에서 설명했던 N - 1개의 노드가 최대라는 것에 대응 돼!) 

 3. 마지막으로, 한번 더 Edge들을 쭉 돌면서 최단 거리를 갱신해보고 
 4. 이때 “갱신되는 것이 있다면” 음수 사이클 (Negative Cycle)이 있다는 것으로 간주. 

*음수 사이클: 순환했을 때 가중치의 합이 음수가 되는 사이클. 

 일단 위의 2번부터 이해해보자. 

![2.jpg](%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB%20-%20%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20(Bellman%20-%20Ford%20-%20Moore)%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20101ba57435d741c89c10a35a0fd02614/2.jpg)

 편의상 1번 node가 우리의 출발점, 1번 자기 자신과의 거리는 0이라 가정할게. 

현재 아무것도 하지 않았으니, 1번 node로부터 각 i번 node로의 거리를 리스트로 나타내면 아래와 같을 거야. 

 dist = [ None, 0, inf, inf, inf, inf ] (None은 그냥 인덱스 번호랑 실제 번호 맞추기용)

따라서 for문의 첫번째 반복에서는 1번과 2번 node를 이어주는 edge만을 살펴보게 돼. 살펴본 edge는 하늘색으로 표시해줄게. 

![3.jpg](%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB%20-%20%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20(Bellman%20-%20Ford%20-%20Moore)%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20101ba57435d741c89c10a35a0fd02614/3.jpg)

 이때 dist = [ None, 0, 2, inf, inf, inf, inf ] 으로 갱신해주면 되겠지? 이제 2번 node에서 출발하는 edge들도 살펴볼 수 있게 되었으니 두 번째 반복에서는 2와 3을 이어주는 edge까지 살펴보게 될 거야. 마찬가지로 표시해주면 아래처럼 되겠지? 

![4.jpg](%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB%20-%20%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20(Bellman%20-%20Ford%20-%20Moore)%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20101ba57435d741c89c10a35a0fd02614/4.jpg)

 또 한 번 반복한다면? 아래처럼 될 거야! 

![5.jpg](%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB%20-%20%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20(Bellman%20-%20Ford%20-%20Moore)%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20101ba57435d741c89c10a35a0fd02614/5.jpg)

 이때, 위 그림들을 잘 살펴보면 각 반복에는 특징이 있다는 걸 알 수 있어. 
1번째 반복에서는 우리의 출발 node에서 edge 1개로 닿을 수 있는 곳까지 갔고, 
2번째 반복에서는 edge 2개로 닿을 수 있는 곳까지 갔고, 
3번째 반복에서는 edge 3개로 닿을 수 있는 곳까지 갔어. (이제 일반화해도 되겠지?) 

—> 그러니까 이제 N - 1번 반복해줬다는 것은 edge N - 1개로 닿을 수 있는 곳까지 가서 최단거리를 갱신해줬다는 것이니까 만약 “모든 가중치가 양수였다면” 다른 모든 node까지의 최단거리가 잘 구해진 상태였겠지? 
 
 여기서 잠깐 의문이 들 수 있는 점을 설명할게! 
 벨만 - 포드 알고리즘 자체는 음수 가중치가 있을 때도 사용 가능한데, 막상 위에서 설명할 때에는 모든 가중치가 양수 (정확히는 0 이상)일 때를 기준으로 설명했지? 
 자세한 설명을 위해 적당히 사이클 A → B → A가 있다고 하자. ( →는 곧바로 간다는 뜻이 아니라 어떤 적당한 경로가 존재한다는 뜻이야! 즉 A → B가 실제로는 A, C, D, B일 수도 있어!) 

 cf. 애초에 두 node A, B에 대해서 사이클이 없었다고 하면 A → B처럼 편도만 가능하니까 당연히 이때는 둘의 최단 거리를 만들어주는 edge들이 많아야 N - 1개 겠지? 
  
 근데 이때 이 사이클의 가중치의 합이 0 이상이라면 (즉, 음수 사이클이 아니라면) 
A → B (많아야 연결된 edge 개수가 N - 1개인 상태) 에서 → A → B → A를 아무리 반복해도 거리가 줄어들지 못해. (반대로 음수 사이클의 경우에는 반복하면 할수록 거리가 줄어들어버리겠지?) 

 즉 애초에 사이클이 있어도 그게 음수 사이클이 아니라면 A → B에서 사이클을 타지 않고 멈추는 것이 거리가 가장 짧은 경로가 되고, 이때에는 사실상 편도니까 여전히 연결해주는 edge의 개수가 
N - 1개 이하라는 거지. 

(잘 이해 안된다면 수정 요청 줘!) 

 따라서 정리하면, 아래의 결론을 얻을 수 있어. 

 Thm. 

 “음수 사이클이 존재하지 않을 경우” 노드가 총 N개인 그래프에서 임의의 두 점 A, B을 잡았을 때 
그 둘을 잇는 최단 경로는 많아야 N - 1개의 edge로만 구성된다. 

—> 자, 이제 벨만 - 포드 알고리즘의 하이라이트인 “음수 사이클 판별”을 해보자. 

 만약, 이미 N - 1번 반복하면서 각 node 까지의 최단 거리를 갱신해준 상태에서 한 번 더 반복한다면 어떻게 될까? 위의 Thm.에 의해 음수 사이클이 없다면 갱신이 안되겠지? 

 **따라서, 벨만 - 포드 알고리즘에서는 N - 1번 반복한 뒤에 딱 한 번 더 edge를 순회했을 때 갱신되는 최단 거리가 있다면 음수 사이클이 있다고 결론을 지어**. (대우 명제라고 생각하면 편해!) 
반대로 갱신되는 최단거리가 없다면 음수 사이클이 없다고 결론 지을 수 있겠지? 
 한편으로, 왜 음수 사이클을 판단하는 게 중요한지 궁금할 수도 있는데, 사실 이에 대한 설명은 이미 이루어졌어! 위에서 말했듯이 음수 사이클의 경우에는 사이클을 계속 돌면 돌수록 최단거리가 계속 감소하고 감소해. 즉, 애초에 내가 특정 시점에서 구한 거리는 절대로 최단거리가 될 수 없어. 
 (약간 고등학교 수학식으로 설명하자면, 최솟값이 존재하지 않는 거지) 

 한마디로 음수 사이클을 판별하는 것은, 애초에 최단 거리를 내가 구할 수 있는 상태였냐? 라고 묻는 셈이지 ㅇㅇ. 

*** 그래서 구현은 어떻게 하는가? (예제 및 코드편) 

(예제 : [11657번: 타임머신 (acmicpc.net)](https://www.acmicpc.net/problem/11657)) 

 말로만 보면 이해하기가 어려우니 예제와 코드도 함께 살펴보자. 
위에 첨부된 문제는 상당히 전형적인 벨만 - 포드 알고리즘 문제에 해당해. 
(굳이 이유를 설명하자면, 내가 출발하고자 하는 도시가 단 하나로 고정이 되어 있고, 가중치가 음수일 수 있기 때문에!) 

```python
#백준 "타임머신" 
import sys 
input = sys.stdin.readline 

n, m = map(int, input().split(' ')) 

dist = [float('inf') for _ in range(n + 1)] # 각 도시로의 최단거리를 무한대로 설정. 
dist[1] = 0 #1번 도시에서 출발한다는 것이 고정. 따라서 초기값 0을 준다. 

edge = [] 

for _ in range(m): 
    start, finish, cost = map(int, input().split(' ')) #각각 출발 및 도착 도시, 가중치
    edge.append((start, finish, cost)) #여기까지는 parsing 부분. 

#-----------------------------------------------------------
for _ in range(n - 1): #벨만 - 포드 알고리즘의 첫 과정. 최단거리를 n - 1번에 걸쳐 갱신
    for i in edge: 
        if(i[2] != float('inf')): 
            dist[i[1]] = min(dist[i[1]], dist[i[0]] + i[2]) 

cycle = False 
for i in edge: #벨만 - 포드 알고리즘의 두 번째 과정. 음수 사이클이 있는지 판단하기. 
    if(i[2] != float('inf')):
        if(dist[i[1]] > dist[i[0]] + i[2]): #최단 거리가 갱신되는 경우가 있다면 
            cycle = True #사이클이 있다고 판단! 

#-----------------------------------------------------------
#이 아래 부분은 문제 정답 출력 부분. 굳이 신경쓰지 않아도 됨!! 
if(cycle): 
    print(-1)
else: 
    for i in range(2, n + 1, 1): 
        if(dist[i] == float('inf')):
            print(-1)
        else:
            print(dist[i])
```

 전반적인 흐름은 이미 설명하기도 했고, 주석으로도 어느 정도 달아두었어! 

그래서 위의 코드에서는 볼 만한 부분은 최단 거리를 실제로 갱신해주는 부분이야. 

일단 이론편에서 최단 거리를 어떻게 갱신했었는지를 생각해보자. 

 우선 내가 고른 node의 최단 거리가 한 번은 갱신된 상태여야 한다는 조건이 있었지? 
우리가 일반적으로 벨만 - 포드 알고리즘을 사용할 때에는 각 node들로의 최단 거리를 무한대 혹은 매우 큰 값으로 두고 특히 위의 코드에서는 무한대인 float(’inf’)로 두었어. 
 따라서 edge의 거리를 가져왔을 때 float(’inf’)가 아닐 때만 (즉, float(’inf’)보다 작을 때만) 판단하면 된다는 거지! 
 (—> 이를 if문으로 적어둔 것이 아래의 조건문)

```python
for i in edge: 
	if(dist[i] != float('inf')): 
```

 이제 이 상태에서 dist [i]를 갱신 해주면 되겠지? 

edge 하나를 내가 택하면 그 edge에는 (출발 node, 도착 node, 가중치)가 있을텐데, 
if문으로 출발 node의 최단 거리가 무한대인 것은 (즉, 아직 출발 node에 도착해본 적이 없는 경우) 이미 걸러냈지? 
 그래서 이제 (출발 node의 최단 거리값 + edge의 가중치)와 (도착 node의 최단 거리값)을 비교해서 전자가 더 작다면, 도착 node의 최단 거리값을 전자로 갱신해주는 거야. 

—> 이때 if문을 한 번 더 사용해도 되긴 하지만, 나같은 경우는 코드를 간결하게 쓰려고 그냥

```python
dist [도착 node] = min(dist [도착 node], dist [출발 node] + edge 가중치) 
```

 위처럼 한줄로 적는 편이야! 

 대신 마지막에 한 번 더 돌면서 음수 사이클이 있는지 확인할 때에는 갱신까지는 할 필요없이 갱신이 가능한지만 보면 되니까 아래처럼 평범한 조건문을 적지. 

```python
if( dist [도착 node] > dist [출발 node] + edge 가중치): #갱신되는 상황이므로 
	cycle = True #음수 사이클이 있다는 뜻. 
	break #반복문을 굳이 끝까지 돌고 싶지 않다면 break 까지 걸어주면 좋겠지? 
```

**** 추가 설명 

 1. 시간복잡도 (그래프의 node의 총 개수를 V, edge의 총 개수를 E라고 했을 때) 

 다익스트라의 경우에는 “모든 가중치가 0 이상” 이라는 제한 조건이 걸린 대신 O( E log V) 이라는 꽤 괜찮은 시간 복잡도를 보여줬어. 
 대조적으로, 벨만 - 포드의 경우에는 “음수인 가중치가 존재해도” 사용할 수 있지만, 그만큼 시간복잡도가 희생되어서 O( V * E )의 시간복잡도를 보여줘. 

—> O( V * E )인 이유? 
 for문을 node의 개수인 V 번 만큼 (최단 거리 갱신을 위해 V - 1번, 음수 사이클 판단을 위해 1번) 모든 edge를 다 살펴보기 때문에 (edge의 개수는 총 E였지?) 시간복잡도가 O( V * E )가 돼! 

2. 참고사항 (**유의미한 사이클 판단하기**) 
 때로는 그래프 전체에 음수 사이클이 있다고 해도, 막상 그 사이클이 실제로는 별 의미 없는 사이클일 수도 있어. (관련 백준 문제: 오민식의 고민 ([1219번: 오민식의 고민 (acmicpc.net)](https://www.acmicpc.net/problem/1219))

 예를 들어서, 아래 같은 그림의 상황이 별 의미 없는 음수 사이클에 해당하겠지? 

![6.jpg](%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB%20-%20%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20(Bellman%20-%20Ford%20-%20Moore)%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20101ba57435d741c89c10a35a0fd02614/6.jpg)

 위 그림의 출발 노드에서 도착 노드로 갈 때에는 음수 사이클을 거치고 갈 수가 없기 때문에, 실제로 최단 거리를 구한다고 하면 잘 구해져야겠지? 

 그러면 결국에는 “음수 사이클이 존재할 때, 출발 노드 → 음수 사이클 → 도착 노드의 경로가 존재하는가?”를 살펴봐야 하는데, 막상 여기서 시간복잡도가 너무 커진다면 벨만 - 포드 알고리즘을 사용하는 의미가 없겠지? 

 다른 해결방법이 있기는 하지만 여기서는 내가 찾아낸 방법을 소개할게. 
일반적으로 최단 거리를 갱신할 때에는, edge가 가리키는 “도착 node”의 최단 거리를 갱신하잖아? 
이것을 음수 사이클에서 값이 갱신되는 node (편의상 A라고 부르자) 의 입장에서 생각해보면…

”A에서 출발해서 A로 되돌아오는 음수 사이클이 존재한다”가 되겠지? 결국에는 A로 다시 들어오는 음수 경로가 있어야 갱신이 될테니까. 

 그렇다면 이제 출발 노드 → 사이클 → 도착 노드가 가능하다는 것은 

1. 출발 노드에서 사이클로 진입하는 것이 가능하다. 
2. 사이클에서 도착 노드로 진입하는 것이 가능하다. 

 이 두 가지가 충족되면 됨을 상기하고 풀이를 생각하자. 

어차피 우리가 

```python
for i in edge: 
	if(dist[i] != float('inf')):
```

 위 코드로 edge들을 순회하니까, 최단 거리를 갱신할지 안할지를 판단할 때에는 
dist [ i ] ≠ float(’inf’) , 즉 출발 노드에서 해당 i 번째 node로 도착하는 것이 가능함이 이미 보장이 되어 있어. 
 즉, 2번만 확인해주면 된다는 뜻이야! 
위에서 논의한 바에 의해서, 어떤 node A의 값이 또 갱신된다는 것은 A에서 출발하여 

A로 다시 되돌아오는, **즉 시작점과 끝점이 모두 A인 사이클을 잡아줄 수 있다**는 소리가 되거든? 
그래서 결국에는 A에서 우리가 원하는 도착 노드로 갈 수 있는지만 DFS / BFS 등으로 확인하면 된다는 거지. 
 이러면 코드 짜기가 (DFS or BFS에 어느 정도 익숙하다는 가정하에) 꽤 편해서, 개인적으로는 괜찮다고 생각하는 풀이야!