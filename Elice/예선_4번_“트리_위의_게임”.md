# 예선 4번. “트리 위의 게임”

< 문제 > 

 정점 N 개의 트리에서 두 사람이 게임을 진행하려 한다. 

각 정점은 1번부터 N 번까지 번호가 매겨져 있고 루트 노드는 1번 노드이다.

게임은 서로 턴을 번갈아 가며 진행되고 트리 위에 놓을 수 있는 말과 함께 진행된다. 

두 사람의 점수는 모두 0점으로 시작한다. 

 각 턴마다 두 사람은 다음과 같은 작업을 반복한다. 

- 현재 말이 놓여 있는 정점의 번호만큼 자신의 점수에 더한다.
- 현재 말이 놓여 있는 정점의 자식 정점이 없다면 그대로 게임을 종료한다. 
자식 정점이 존재한다면 자식 정점 중 원하는 자식 정점으로 말을 옮긴다.

 게임이 종료되었을 때 선공의 점수가 후공의 점수보다 높거나 같다면 선공이 승리하고 아니라면 
후공이 승리한다. 두 사람이 최적으로 플레이할 때, 처음 말이 놓여져 있는 정점의 번호에 따라 
선공이 이기는지 후공이 이기는지 구해보자. 

< 입력 > 

- 첫째 줄에 정점의 수 N 이 주어진다. ( 1 ≤ N ≤ 10^5 )
- 둘째 줄부터 N - 1 개의 줄에 간선을 나타내는 정수 u , v가 주어진다. ( 1 ≤ u, v ≤ N )
이는 u 번 정점과 v 번 정점을 잇는 간선이 존재한다는 뜻이다.

< 출력 > 

- N 개의 줄에 걸쳐 정답을 출력한다.
- i 번째 줄에는 말의 시작위치가 i번 정점일 때의 결과를 출력한다.
- 선공이 이긴다면 1을 후공이 이긴다면 0을 출력한다.

( 쉼표같은 게 없어서 불편하다구요? 실제 대회 지문이 이랬어요…ㅠㅠ )    

 < 해설 > 

 예선 3번까지는 그래도 PS 경험이 많다면 무난하게 풀 수 있었는데, 이 문제부터 약간 본격적으로

어려워지기 시작했다는 느낌이 드네. 참고로 이 문제에서 말은 “1개”만 사용하는데, 이러한 점도 

명시가 안 되어 있었기에 여러모로 이해하는 데에 많은 시간이 걸렸어… 

 우선 본격적으로 풀기 이전에 주어진 예시 입력과 출력을 살펴보자. 

** 입력 예시 2 

6
1 3
1 2
3 5
3 6
2 4

** 출력 예시 2

1
0
0
1
1
1

![4번문제.jpg](%E1%84%8B%E1%85%A8%E1%84%89%E1%85%A5%E1%86%AB%204%E1%84%87%E1%85%A5%E1%86%AB%20%E2%80%9C%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%B1%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E2%80%9D%201bbc01776c514ece87bb9c1fa18bcc2a/4%25EB%25B2%2588%25EB%25AC%25B8%25EC%25A0%259C.jpg)

 우선 위 그림에서 쉽게 알 수 있는 건, 트리에서 가장 맨 밑에 있는 노드들 (즉, 리프 노드들)에서는

무조건 선공이 이긴다는 점이야. 더 이상 자식 노드가 없기 때문에, 그냥 거기에 적혀 있는 점수를

선공이 얻은 뒤에 게임이 끝나기 때문.

 그러니 4, 5, 6번 노드에서 게임을 시작하면 선공이 이기니까 예시 출력 2의 마지막 1 세 개는 이해가 

되었어. 마저 출력을 살펴보면, 2번과 3번 노드에서 게임을 시작하면 후공이 이긴다고 되어 있으니 

예를 들어서 3번 노드에서 게임을 시작했다고 해보자. 

 1. 선공이 3점을 얻고, 이후 자식 노드인 5번 또는 6번 노드로 말을 옮겨야 해. 

    → 선공이 최선의 수를 둔다면, 6번 보다는 5번 노드에 두어야 겠지? 

 2. 이제 후공이 5점을 얻고, 더 이상 자식 노드가 없으니 후공이 이기는 것으로 게임이 끝나. 

 이 예시를 생각해보면, 최선의 수를 둔다는 건 기본적으로 상대방이 얻는 점수가 최대한

적게끔 해야 한다고 느껴질 수도 있어. 근데 조금만 잘 생각해보면, 이러한 접근의 허점을

눈치챌 수 있어. 

![4번 문제_2.jpg](%E1%84%8B%E1%85%A8%E1%84%89%E1%85%A5%E1%86%AB%204%E1%84%87%E1%85%A5%E1%86%AB%20%E2%80%9C%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%B1%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E2%80%9D%201bbc01776c514ece87bb9c1fa18bcc2a/4%25EB%25B2%2588_%25EB%25AC%25B8%25EC%25A0%259C_2.jpg)

 위와 같이 트리가 주어지면, 3번 노드에서 시작했을 때 선공은 “5번이 아닌” 6번 노드로 말을 옮기는

것이 최선의 수야. 비록 후공이 6점을 얻긴 하지만, 그 다음에 선공이 7점을 얻어서 승리하게 되거든. 

지금까지의 생각을 정리해보면, 아래와 같이 나타내볼 수 있어. 

1. 그냥 단순하게 상대방이 가장 낮은 점수 / 가장 높은 점수를 갖도록 하는 게 최선은 아니다. 

    → 약간 고급지게 말하면, 위와 같은 그리디한 전략은 통하지 않는다고도 할 수 있어. 

 2. 그럼 어떤 것이 최선의 수인가? 

    → 각 자식 노드로 갔을 때마다 내가 얻는 점수와 상대방이 얻는 점수가 달라지니까, 편하게

       ( 내가 얻을 수 있는 점수 - 상대방이 얻을 수 있는 점수 )가 가장 큰 경우를 택하면

       되겠지? 

”뭔가 최소 / 최대를 구해야 하는데 그리디로는 잘 안풀린다”

→ DP를 생각해볼 수 있는 상황 중 하나야.

→ 특히 위에서 ( 내가 얻을 수 있는 점수 - 상대방이 얻을 수 있는 점수 )를 최대로 하고 싶었으니 

→ 각 노드별로 dp [node][0] = ( node 번 노드에서 출발했을 때 내가 얻을 수 있는 점수 )

                        dp [node][1] = ( node 번 노드에서 출발했을 때 상대가 얻을 수 있는 점수 )
    
   라고 정의한 뒤 DP를 구현해주면 돼. ( 내 후배는 위처럼 2차원 DP로 해결했어. ) 

Q. “내 후배는“ ? 

A. ㅇㅇ. 나도 원리는 똑같은데, 점화식이 약간 달라. 아래의 그림들을 살펴보자. 

![4번 문제_3.jpg](%E1%84%8B%E1%85%A8%E1%84%89%E1%85%A5%E1%86%AB%204%E1%84%87%E1%85%A5%E1%86%AB%20%E2%80%9C%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%B1%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E2%80%9D%201bbc01776c514ece87bb9c1fa18bcc2a/4%25EB%25B2%2588_%25EB%25AC%25B8%25EC%25A0%259C_3.jpg)

 어때? 

 1번 노드에서 시작해서 “1번 → 3번 → 6번 → 7번”을 가는 거랑 “3번 → 6번 → 7번”을 가는 거랑 

꽤 느낌이 비슷하지 않아? 

 선공 입장으로 약간 풀어서 적어보면 1 - 3 + 6 - 7 = 1 - (3 - 6 + 7)로 적을 수 있다는 거지. 

Q. 그건 알겠는데 그걸로 뭘 할 수 있죠? 

A. 어차피 선공이든 후공이든 시작 위치가 같으면 자신이 얻을 수 있는 점수가 똑같잖아? 

   그러니까 처음부터 dp [node][0] , dp [node][1] 처럼 구분할 필요없이 

   dp [node]를 ( node 번 노드에서 출발했을 때 그 사람이 얻을 수 있는 최대 점수 )로 정의하면

   된다는 거지. 

    조금 더 구체적으로 설명하자면, 위의 1 → 3 → 6 → 7 예시에서 
   dp [1] = 1 - dp [3] = 1 - ( 3 - dp [6] ) = 1 - ( 3 - ( 6 - dp [7] ) ) = 1 - ( 3 - ( 6 - 7 ) ) 

             = 1 - 3 + 6 - 7 이 성립한다는 거야. 

   따라서 점화식을 아래처럼 적어줄 수 있어. 

   dp [node] = max ( node - dp [ (node번 노드의 자식 노드들) ] )

 지금까지의 내용으로 코드를 한 번 짜볼게. 

다만 주의해야할 점이, 여기서 DP를 구현하는 건 일반적인 DP 문제들하고는 약간 느낌이 달라. 

( 백준에서도 “트리에서의 다이나믹 프로그래밍”이라고 이름 붙여줬을 정도야. ) 

보통 이런 류의 DP 문제를 “Tree DP”라고 부르는데, 딱 이 문제가 Tree DP의 좋은 예시이기도 하니 

처음 보는 유형이라면 어떤 식으로 구현하는지 잘 관찰하는 게 좋아! 
 

```python
from collections import deque 
import sys 
input = sys.stdin.readline 

n = int(input())

edge = [[] for _ in range(n + 1)] 
# node 번호는 1번부터 n번까지. 
for _ in range(n - 1):
	a, b = map(int, input().split(' ')) 
	edge[a].append(b) 
	edge[b].append(a) 
	# 당장 입력받을 때는 어느 쪽이 부모 노드인지 모르니까 간선을 양방향으로 두자. 
	
# DP를 풀 때는 항상 "그냥 구할 수 있는 케이스"를 생각해줘야 해. 
# 수열로 생각하면 첫째항 느낌? 

# 위에서 맨 처음에 설명할 때는 "리프 노드에서는 선공이 무조건 이긴다" 라고 
# 했지만, 점수로 생각해주면 "리프 노드에서는 그냥 거기 적혀 있는 점수만큼 얻고 끝"이겠지?
# 다만 지금은 어떤 애들이 리프 노드인지도 모르니까 
# 리프 노드들부터 BFS 혹은 DFS로 찾아주어야 해. 

leaf = [True for _ in range(n + 1)] 
queue = deque([(1, 0)]) # 루트 노드는 항상 1번. 
# 이때 queue에는 (현재 node, 직전에 방문한 node) 형태로 넣어줄거야.
# 원래 BFS / DFS를 할 때에는 visited 배열을 사용하는 게 일반적인데, 
# 지금처럼 주어진 그래프가 트리라면 visited 배열을 사용하지 않고도 풀 수 있어. 
# 자세한 건 추후에 작성될 예정인 "no-prev BFS" 참고. 

while(queue): 
	node, prev = queue.popleft() 
	
	for nx in edge[node]: 
	# 우리가 입력을 받을 때 "양방향 간선"으로 입력을 받았기 때문에
	# nx에는 node의 부모 노드도 들어가게 돼. 
	# 이때 prev 변수에 부모 노드를 미리 저장해서 넘겨주면
	# 부모 노드로 다시 되돌아가는 일을 막아줄 수 있지? 
	# 이걸 정확히 뭐라고 부르는지는 모르겠는데 일단 난 no-prev BFS라고 부르는 편이야. 
	
		if(nx != prev): 
		# 부모 노드가 아닌 다른 노드가 nx에 들어왔다는 것은, 
		# 현재 내가 보고 있는 노드의 자식 노드가 존재한다는 뜻이야. 
		# 즉, 리프 노드가 아니라는 뜻! 
			leaf[node] = False 
			queue.append((nx, node)) 
			
# 여기 도달 --> 리프 노드 여부 판단 완료. 이제 본격적으로 DP를 구현하자. 

dp = [float('-inf') for _ in range(n + 1)] 

def dfs(node, prev): 
	# 주어진 상황 자체가 임의의 트리 구조를 가질 수 있다보니, 
	# dp[n + 1] = dp[n] + dp[n - 1] --> 이런 식으로 식이 고정되어 있지 않아. 
	# 따라서 dp 값을 계산하는 과정 자체도 BFS 혹은 DFS로 진행해주어야 하는데, 
	# 여기서는 DFS로 진행해줄게. 
	
	# 참고로 여기서도 visited 배열은 no-prev 기법으로 생략할 수 있어. 
	if(dp[node] > float('-inf')):
		# 만약 dp값을 이미 구해두었다면 
		return dp[node] 
	elif(leaf[node]): 
		# dp 값을 구해두지는 않았는데
		# leaf node라서 그냥 구해줄 수 있다면 
		dp[node] = node 
		return dp[node] 
		
	for nx in edge[node]: 
		if(prev != nx): 
			dp[node] = max(dp[node], node - dfs(nx, node)) 
			# 구해둔 점화식 기억나지? 
			
	return dp[node] 
	
	
dfs(1, 0) # 참고로 0번 노드는 절대로 부모 노드일 수 없으니 적당히 넣어준 값이야. 
# 0이 아니라 float('inf')같은 값이어도 상관은 없어! 

for i in range(1, n + 1, 1): 
	if(dp[i] >= 0): 
		print(1) 
	else: 
		print(0) 

# dp [node] -> 해당 node에서 얻을 수 있는 최대 점수였으니
# dp [node] < 0 이라면 선공이 지는 것이고, 
# 아니라면 선공이 이기는 거겠지? 점수가 같아도 선공이 이기는 거에 주의하자
```