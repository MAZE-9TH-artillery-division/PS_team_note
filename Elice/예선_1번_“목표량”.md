# 예선 1번. “목표량”

< 문제 > 

 엘리스 토끼는 목표량을 정해 수학 문제를 열심히 풉니다. 목표량은 정수입니다.

내일 풀 수학 문제의 개수는 오늘 푼 문제 개수의 수와 숫자의 구성이 같으면서, 오늘 푼 문제 개수의 수보다 큰 수 중 가장 작은 수입니다.

예를 들어, 오늘 67문제를 풀었으면 다음 날 76문제를 풉니다.

오늘 푼 문제의 개수를 줬을 때 다음날 풀 문제의 개수를 출력하는 프로그램을 작성하세요.

( 시간 제한 : 1초 )

< 입력 > 
 첫 번째 줄에 오늘 푼 문제의 개수인 자연수 *N*을 입력합니다. ( 1 ≤ *N* ≤ 999,999 ) 

정답이 반드시 존재하는 경우만 입력값으로 주어집니다. 

< 출력 > 

 다음날 풀 문제의 개수를 출력합니다. 

예시) 입력 : 364 → 정답: 436

< 해설 > 

 우선 주어진 조건에서 N은 해봤자 6자리 수. 

따라서 O ( (N의 자릿수)! ) 같은 상당히 큰 시간복잡도를 사용해도 1초 내에 정답을 낼 수 있어. 

즉, dfs 등을 이용해서  주어진 숫자의 각 자릿수에 대한 순열들을 구하면서

원래 숫자들보다 큰 것들만 살펴보면 돼. 

```python
num = input()

count = [0 for _ in range(10)] # 숫자 0부터 9까지. 
for i in num: 
    count[int(i)] += 1 

ans = float('inf')
def dfs(string): 
    global ans 
    if(len(string) == len(num) and int(string) > int(num)):
        ans = min(ans, int(string)) 
        return 

    for i in range(0, 10, 1): 
        temp = 0 
        for j in string: 
            if(j == str(i)): 
                temp += 1 
        
        if(temp < count[i]): # 아직 내가 i를 추가해줄 수 있다면 그냥 추가해줘버리자.
            dfs(string + str(i))

dfs("") 
print(ans) 
```

( 만약 위 코드가 잘 이해 안된다면 백준의 N과 M 시리즈를 먼저 해결해보고 올 것! ) 

- [ ]  공부해오겠슴니다…

( 설명 조금 더 친절하게 고칠 예정 )