# 예선 3번. “문자열 압축 해제”

< 문제 > 

 엘리스 토끼는 문자열을 직접 압축 해제하려고 합니다. 

 압축되지 않은 문자열 S 가 주어졌을 때, 이 문자열 중 어떤 부분 문자열은 K ( Q ) 와 같이 압축할 수

있습니다. 이것은 Q 라는 문자열이 K 번 반복된다는 뜻입니다. K 는 한 자릿수의 정수이고, 

Q 는 0 자리 이상의 문자열입니다. 

 예를 들면, 53(8)은 다음과 같이 압축을 해제할 수 있습니다. 

![1.JPG](%E1%84%8B%E1%85%A8%E1%84%89%E1%85%A5%E1%86%AB%203%E1%84%87%E1%85%A5%E1%86%AB%20%E2%80%9C%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%A7%E1%86%AF%20%E1%84%8B%E1%85%A1%E1%86%B8%E1%84%8E%E1%85%AE%E1%86%A8%20%E1%84%92%E1%85%A2%E1%84%8C%E1%85%A6%E2%80%9D%2082f2767bafd641a09ce0d091aed95f27/1.jpg)

 압축된 문자열이 주어졌을 때, 이 문자열을 다시 압축을 푸는 프로그램을 작성하세요. 

< 입력 > 

- 첫째 줄에 압축된 문자열 S를 입력합니다.
- S 의 길이는 최대 50 입니다.
- 문자열은 ( , ) , 숫자로만 구성되어 있습니다.

< 출력 > 

- 압축되지 않은 문자열의 길이를 출력합니다.

< 입력 예시 > 

11(18(72(7)))

< 출력 예시 > 

26

** 참고 : 백준 1662번 “압축” 문제와 동일한 문제임. ( 입력 제한 조건만 약간 다름 ) 

[1662번: 압축 (acmicpc.net)](https://www.acmicpc.net/problem/1662)

< 해설 > 

 이 문제의 경우 우선 먼저 풀어보면 좋은 문제가 있어. 아직 아래의 문제를 풀어보지 않았다면, 

지금 풀어보고 오자! 

[9012번: 괄호 (acmicpc.net)](https://www.acmicpc.net/problem/9012)

 위의 문제를 풀고 나면 주어진 괄호 문자열이 올바른지의 여부를 판단할 수 있어. 

그리고 이 문제에서의 핵심은, 위의 방법을 응용하면 “함수의 범위가 어디까지인지”를 알아낼 수 

있다는 거야. 

 예를 들어 아래의 합성 함수 관련 식을 생각해보자. 

![2.JPG](%E1%84%8B%E1%85%A8%E1%84%89%E1%85%A5%E1%86%AB%203%E1%84%87%E1%85%A5%E1%86%AB%20%E2%80%9C%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%A7%E1%86%AF%20%E1%84%8B%E1%85%A1%E1%86%B8%E1%84%8E%E1%85%AE%E1%86%A8%20%E1%84%92%E1%85%A2%E1%84%8C%E1%85%A6%E2%80%9D%2082f2767bafd641a09ce0d091aed95f27/2.jpg)

 위 식을 우리가 계산한다고 하면 우선 함수 f 안에 들어가는 식이 어디부터 어디인지 알아내야 하고,

위의 예시는 상당히 간단하다보니 f 안에 g ( h ( x ) ) 가 들어간다는 것을 쉽게 알 수 있어. 근데 

이러한 것을 코드로는 어떻게 구현해야 할지가 문제겠지? 

 생각해보면 우리가 위의 식을 생각할 때는, ( 물론 방식은 사람마다 다를 수 있겠지만 최소한 나는 )

“f ( “의 괄호 ‘ ( ’ 가 닫힐 때까지 계속 다음 글자를 읽어나가지? 마찬가지로 이 “닫힌다”라는 것을 

판단할 수 있게 코드로 구현해주기만 하면 되고, 이걸 요구하는 것이 위의 9012번 문제야. 

 즉 정리하면, 함수에게 넘겨지는 인자가 어디부터 어디까지인지를 올바른 괄호 문자열 문제로 

생각해서 풀 수 있다는 뜻이야.

 이렇게 인자가 어디부터 어디까지인지를 알아냈으면 이젠 함숫값을 계산해주면 되겠지? 그런데 

생각해보면 인자값도 위의 예시처럼 또 식의 형태일 수도 있어. 그러면 다시 인자에게 넘겨지는

인자가 어디부터 어디까지인지를 계산해서… —> 이 과정을 반복해줘야겠지? 이렇다보니 

자연스럽게 재귀 함수를 사용하는 풀이를 생각해볼 수 있어. 

 이 정도면 아이디어는 다 설명했으니 코드를 살펴보자. 생각보다 간단하니 먼저 풀어보려고 해보는

것도 좋을 것 같아. 

```python
from collections import deque 
# 나는 올바른 괄호 문자열을 판별할 때 스택을 사용하는 편인데, 
# 스택을 사용하지 않는 풀이도 있으니 꼭 스택을 사용할 필요는 없어! 

string = input() 

def func(string): 
    # 입력받은 문자열의 압축 해제 후 길이를 구하는 코드. 

    if(len(string) <= 1): 
        # string의 길이가 1이면 숫자 하나만 있는 것이고
        # 길이가 0이면 ( 문제 입력에서는 K (Q)에서 Q 가 0 자리일 수도 있다고 했으니...) 그냥 0을 리턴해주면 되니까 
        return len(string) 
    
    # 주어진 문자열은 사실 아무런 압축을 하지 않은 문자일 수도 있어.
    # 다만 일반적인 문자열 또한 숫자로 주어지니까, 가장 확실하게 압축이 일어났는지 확인하는 방법은 괄호를 찾는거야. 
    # 그러니 우선은 괄호를 찾을 때까지 주어진 문자열을 살펴보자. 

    idx = length = 0 # 일반적인 문자열의 길이는 length에 담아주자. 
    while(idx < len(string)): 
        if(string[idx] != "("):
            length += 1 
            idx += 1 
        else: 
            break 
    
    if(idx < len(string)): # 이 경우에는 중간에 괄호를 찾은 경우. 
        length -= 1 
        # 괄호 앞에 있는 숫자는 반복 횟수니까 일반적인 문자열의 길이는 1을 빼야 올바르게 계산이 돼. 

        multiple = int(string[idx - 1]) # string[idx] == "(" 이니까 반복 횟수는 idx - 1에 있는 숫자야. 
        stack = deque() 
        temp = idx # 이제 우리가 찾은 괄호가 나타내는 범위를 "올바른 괄호 문자열"을 이용해서 찾자. 
        while(temp < len(string)): 
            if(string[temp] == "("): 
                stack.append("(")
            elif(string[temp] == ")"): 
                stack.pop() 

                if(not stack): 
                    break # 스택이 비어있다 --> 괄호가 완전히 사라지는 순간을 찾았다! 
            temp += 1         
            
        # 이때 함수에 넘겨지는 문자열은 string[idx + 1] ~ string[temp - 1] 인데, 인덱스를 헷갈리지 않도록 조심! 

        return length + multiple * func(string[idx + 1 : temp]) + func(string[temp + 1 : ])
    
        # Q. 엥 마지막에 func(string[temp : ]) 얘는 뭐임? 
        
        # A. 남은 부분도 압축 해제 후의 길이를 구해줘야죠 ㅎㅎㅎㅎ 

    else: # 아무런 괄호가 없다면 그냥 length를 그대로 return 해주면 되겠지? 
        return length 

print(func(string)) 
```