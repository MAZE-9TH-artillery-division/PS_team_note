# MinMax 알고리즘

### * MinMax 알고리즘이란?

턴 제 게임 인공지능을 만들 때 사용할 수 있는 알고리즘으로 내 차례에는 나에게 가장 이득이 되는 행동(max)을, 상대차례에는 나에게 가장 손해(min)가 되는 행동을 하게된다는 가정하에 현재 어떤 행동을 하는것이 가장 이득인지 판단하는 알고리즘임.
체스나 틱택토같은 게임의 인공지능을 이 알고리즘을 통해 만들 수 있다.

![Untitled](MinMax%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20f0f5f7b1b77b4a16affbf636b24c8499/Untitled.png)

MinMax 알고리즘의 진행을 나타내는 이미지 (0, 2, 4는 내 차례 1, 3은 상대 차례 → 0에서 1로 갈때는 최대값, 1에서 3으로 갈때는 최소값 선택하게 됨)

- MinMax 알고리즘의 진행과정
    1. 설정한 깊이만큼 깊이우선 탐색을 실행하여 모든 서브 노드를 탐색.
    2. 모든 서브 노드가 탐색 되었다면 탐색된 맨 아래계층의 노드부터 상위계층으로 평가를 반영하며 올라간다
    3. 모든 평가가 반영된 노드를 선택
    

위 이미지의 트리에서 진행되는 과정을 설명하자면

1. 깊이를 4로 설정(즉 4수 앞까지 반영)하여 모든 노드를 탐색
2. 4층의 값들은 [10, inf, 5, -10, 7, 5, -inf, -7, -5]
3. 3층으로 올라옴. 3층은 상대의 차례 즉, 나에게 불리한 최소값을 아래 계층에서 고른다. → [10, 5, -10, 5, -inf, -7]이 선택됨.
4. 2층으로 올라옴. 2층은 나의 차례이므로 나에게 유리한 최대값을 아래 계층에서 고른다. → [10, -10, 5, -7]이 선택됨.
5. 1층으로 올라옴. min. 최소값 선택 → [-10, -7]
6. 0층 내 차례에서 최대값 선택 → [-7]
7. 따라서 MinMax 알고리즘에 따르면 오른쪽 노드를 선택하는 결과가 나온다.

![Untitled](MinMax%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20f0f5f7b1b77b4a16affbf636b24c8499/Untitled%201.png)

틱택토 게임에서의 트리

### 문제점

모든 노드를 탐색해야 하기 때문에 선택지가 많아지거나 탐색깊이를 늘리게되면 계산시간이 매우 길어진다. 그래서 이 문제를 일정 부분 해소해주는 **알파베타 가지치기**  가 존재한다.

## 알파베타 가지치기

개념 : 진작에 가능성이 없는 경우의 수를 쳐내 탐색해야할 노드의 수를 줄인다.

아래의 트리로 설명함

![Screen Shot 2023-11-08 at 10.15.21 PM.png](MinMax%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20f0f5f7b1b77b4a16affbf636b24c8499/Screen_Shot_2023-11-08_at_10.15.21_PM.png)

회색 노드들은 알파베타가지치기가 적용되어 탐색되지 않은 노드들이다.

![Screen Shot 2023-11-08 at 10.09.55 PM.png](MinMax%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20f0f5f7b1b77b4a16affbf636b24c8499/Screen_Shot_2023-11-08_at_10.09.55_PM.png)

![Screen Shot 2023-11-08 at 10.13.12 PM.png](MinMax%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20f0f5f7b1b77b4a16affbf636b24c8499/Screen_Shot_2023-11-08_at_10.13.12_PM.png)

4→3층 (min): 작은값 선택

5, 6을 탐색 → 5 선택

이후 7, 4, 5를 탐색하기 시작. 7을 탐색하고… 4를 탐색하고.. 그리고 5를 탐색하기 전에!! 

- 만약 4보다 작은 수가 나온다? 그러면 그 수를 선택하겠지만 어차피 3층보다 위의 2층(max)에서는 4보다 작거나 같은 값보다 큰 값인 5를 선택할것!
- 만약 4보다 큰 수가 나온다? 3층(min)에선 더 작은 값을 고르므로 선택되는 수는 4!

따라서 앞 가지에서 선택된 5보다 작거나 같은 4가 나온 순간 이후의 노드를 탐색할 의미는 없어진다@!!!@!
이런 식으로 반복하다보면 전체 트리의 회색노드들처럼 탐색하지 않아도 되는 노드들이 생겨 같은 시간안에 더많은 탐색을 해낼 수 있다.

min층 아래 가지를 자르는 걸 알파 가지치기(나에게 유리한게 확실한 노드를 상대가 고를리 없음→알파 가지치기), max층 아래 가지를 자르는 걸 베타 가지치기(내가 불리해지는게 확실한 노드는 탐색 X → 베타 가지치기)라고 한다.

```python

```