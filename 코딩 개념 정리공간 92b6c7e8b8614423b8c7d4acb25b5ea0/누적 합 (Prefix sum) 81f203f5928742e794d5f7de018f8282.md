# 누적 합 (Prefix sum)

- 관련 백준 문제: (추가 예정)

** 언제 사용할 수 있는 알고리즘인가? 

 배열이 하나 주어졌을 때 i ~ j번째 원소의 합을 구하라고 하면 for문으로 구하는 것을 바로 떠올릴 수 있겠지만, 

 이 짓거리를 여러 번 하라고 하면 상당히 곤란해지는 것이 1 ~ i번째 원소의 합을 i = 1 ~ n까지 하라고 하면 당장 n(n+1) / 2 번의 덧셈이 필요해지니까 시간복잡도가 O(n^2)이 되어버려. 

 이러면 이제 자연스럽게 위의 O(n^2)을 좀 줄일 수 없겠냐는 질문을 하게 될 테고… 

  “배열은 그대로인데” 합을 여러 번 구해야 하거나, 합을 좀 편하게 구해야할 때 사용가능한 알고리즘이 이번에 소개할 “누적 합 (Prefix sum)” 알고리즘이야! 

—> 배열이 달라질 때는 세그먼트 트리 (segment tree) 등의 방법을 사용하는데 이는 나중에 따로 다룰 예정! 

*** 그래서 구현은 어떻게 하는가? 
(참고 문헌: Codeground Note [https://www.codeground.org/practice](https://www.codeground.org/practice)) 

 의외로 구현 방법은 상당히 간단해.  

그냥 미리 1 ~ n번째 원소까지의 합을 배열에 저장해두는 것! 

<예제 코드> 

![Untitled](%E1%84%82%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%A8%20%E1%84%92%E1%85%A1%E1%86%B8%20(Prefix%20sum)%2081f203f5928742e794d5f7de018f8282/Untitled.png)

(잘 안보이면 우클릭 - 원본 사진 보기) 

 위는 백준 11659번 (구간 합 구하기)의 내 풀이 코드야. 숫자 배열과 m개의 줄에 걸친 i, j들이 주어질 때 i번째 ~ j번째 원소의 합을 m번 출력하는 것이 문제의 요구사항. 

 코드를 보면 리스트를 한 번 받고 for문으로 inform[i] += inform[i - 1] 코드를 실행했는데, 이 코드를 실행하고 나면 

 (기존의 1 ~ i번째 원소의 합)이 i번째 원소로 업데이트가 되는거야!

 고등학교 수학으로 설명하면 a_n이 주어졌을 때 S_n으로 바꿔서 저장해주는 거지. 

 그럼 이 다음에는 어떻게 하냐? 

i번째 ~ j번째의 원소의 합을 구하고 싶은 거면 

1 ~ j번째까지의 합에서 1 ~ (i - 1)번째까지의 합을 빼주면 됨을 이용해서

inform[j] - inform[i - 1]을 출력하는거야! 
(대신, i = 1인 경우에는 빼면 안될테니까 따로 처리를 해주면 되겠지?) 

*** 근데 이게 왜 좋은 알고리즘? 

 주어진 배열을 누적 합으로 고치는 과정이 마음에 걸릴 수 있긴 한데, 잘 생각해보면 

 주어진 배열을 쭉 돌면서 누적 합으로 고치는 과정은 O(n), 이후에 각 i, j에 대해서 구간합을 구하는 과정은 O(1)이니까 
 
 구간합을 구하는 횟수가 많으면 많을수록 시간 복잡도상에서 어마어마한 이득을 보겠지? 

 **** 주의 사항? 

 기본적으로 주의사항은 딱히 없지만, 활용도가 꽤 높으면서도 생각보다 “이거 뭔가 누적 합 쓰면 될 거 같다!” 라는 각이 일단 내 수준 (골드 중위)까지는 잘 보여서 알아두면 상당히 좋아!