# 유니온-파인드 (Union - Find)

- 관련 백준 문제: (추가 예정)

** 어떤, 그리고 언제 사용할 수 있는 알고리즘인가? 

 일반적으로 Union - Find 라고 부르는 이 알고리즘은 정확히 하자면 

Union 알고리즘 + Find 알고리즘으로 구성되었다고 할 수 있어. 

 쉽게 설명하자면 Union은 두 집합을 합치는 것, Find는 각 집합의 대표 원소를 찾는 것이라고 할 수 있지. 

 다만 수학적 표현이 익숙하지 않은 사람은 위의 표현도 와닿지 않을 수 있으니 간단한 예시를 들게. 

 카운터사이드의 “용혈”을 생각해보자. 
시윤이가 결혼을 하고… 자식을 낳고.. 등등 시간이 흐르다보면 시윤의 자손들이 생기겠지? 

 그 뿐만이 아니라, 넓게는 시윤과 시윤의 자손들이 결혼하는 사람도 시윤 가문의 일원으로 봐야할 거야. 

 이때, 새로 태어난 시윤의 자손 혹은 시윤 가문의 사람과 결혼하는 사람들을 “시윤 가문에 포함시켜주는 것”이 Union, 

 한 사람을 딱 골랐을 때 “그 사람이 시윤 가문의 사람인가?”를 알아내는 것이 Find라고 생각하면 그나마 편하게 이해할 수 있을 것이라고 생각해. 
 (이래도 이해 안되면 톡방에 질문 ㄱ) 

 실제 문제에서는, 주어진 요소들을 여러 집합으로 분리하면 좋을 것 같을 때 쓸 수 있다고 보면 충분할 것 같아! 

 *** 그래서 구현은 어떻게 하는가? 
(참고 문헌: Do it 알고리즘 코딩 테스트 : 파이썬 편) 

 설명은 상당히 길었지만, 의외로 구현 자체는 제법 간단한 알고리즘이야.  

 1. Find 
( 보통은 Union을 먼저 설명하는 데, 어차피 Union도 Find 알고리즘을 필요로 하기 때문에 Find 먼저 설명할게!) 

 사실 Union - Find 에서 가장 핵심적인 것은 Find 알고리즘이야. 
 Find 알고리즘을 기반으로 Union 알고리즘이 돌아가고, Find 알고리즘 덕분에 프로그램의 시간복잡도가 크게 감소하기 때문에, 일단 Find부터 살펴볼게. 

 Find 알고리즘의 기본 마인드는…

”그래서 얘네 가문 시작이 누구라고?” 

 위에서 살폈던 시윤 가문으로 또 얘기해보자면

 한 사람을 골랐을 때 그 사람이 시윤 가문의 사람인지, 그러니까 “계속해서 그 사람의 부모 혹은 가족을 타고 

 가계도를 거슬러 올라가다보면” 시윤이가 나오는지를 살펴보는 거야. 

아래와 같은 list를 생각하자. 

(i 번째 사람 ——> i - 1 번 인덱스) 

node = [ 1, 1, 2, 4, 4 ] 

 “3번째 사람 (2번 인덱스)의 가장 높은 조상은 누구인가?” 라고 물으면 Find 알고리즘에서는…

1.  node[2]를 살펴본다. 
2. 값이 3인가? 
3. 아니다. 
4. 그러면 node[2]에 적혀 있는 사람을 살펴보자. 
5. 값이 2이다. 2번째 사람에 해당하는 node[1]을 보자.
6. 값이 1이다.  
7. 역시 2가 아니니 다시 node[1]에 적혀 있는 사람을 살펴보자.
8. 1이 적혀 있다. 그럼 1번째 사람에 해당하는 node[0]을 보자. 
9. node[0]은 1, 즉 자기 자신이다.
10. ㅇㅋ. 그럼 그 위로는 더 없다는 뜻이니까, 3번의 가장 높은 조상은 1번이다. 

 

 위와 같은 과정으로 3번의 가장 높은 조상을 1번 사람으로 결정을 해. 적다보니까 꽤 길긴 하지만 결국에는 “인덱스 번호와 실제로 적혀 있는 값이 일치할 때까지” 계속 같은 작업을 반복하는거지? 
 그래서 보통은 아래와 같이 재귀 함수로 작성을 해. 

```python
def find(a): 
    if(node[a] == a): 
        return a 
    else: 
        node[a] = find(node[a]) ##
        return node[a] 
```

 코드가..상당히 쉽죠? 
상황만 이해하면 정말 쉽고 간결하게 작성할 수 있기 때문에, 문제 몇 개만 풀다보면 아마 외워지기도 할 거야. 

(## 표시된 코드는 반드시 아래의 주의사항을 읽어볼 것!)

2. Union 

 Union은 쉽게 생각해서 두 개의 가문을 연결해주는 건데, 핵심 아이디어만 잘 이해하면 돼. 

”연결은 가장 높은 조상끼리만 한다. 나머지는 Find가 알아서 함 ㅇㅇ” 

 무슨 소리냐면..

[1, 1, 1, 4, 4] 에서 3번째 사람과 5번째 사람이 결혼을 하니까 Union을 해준다고 하자. 

 그러면 직접 3번째 사람과 5번째 사람을 연결하는 것이 아니라, 각각의 가장 높은 조상인 1번째 사람과 4번째 사람을 연결해버리는 거야! 

 가장 높은 조상을 연결하려고 하니, 특정 사람을 넣었을 때 그 사람의 가장 높은 조상을 알려주는 기능이 필요하겠지?  

 → 위에서 만든 Find를 여기서 쓰는 거야! 

 이제까지의 내용을 잘 이해했다면 쉽게 이해할 수 있으니 바로 코드를 보자. 

```python
def union(a, b): 
    a = find(a) 
    b = find(b) 

    if(a ≠ b):
			node[b] = a 
```

역시 코드는 참 간단하죠? 

 각각의 조상을 가져왔을 때, 일치하면 뭐 딱히 해줄 것이 없지만 

 조상이 다를 때에는 둘 중 하나의 조상을 다른 쪽으로 수정해주는 작업을 해주는 거지. 

 예를 들어 [ none, 1, 1, 1, 4, 4] 에 대해서 Union(3, 5) 를 해준다면, 

find(3)은 1, find(5)는 4니까 

node[4] = 1이 실행되어서 

결과는 [ none, 1, 1, 1, 1, 4]가 돼. 
 

**** 주의 사항 및 추가 설명 

1. 주의 사항
 자, 위의 글의 마무리는 상당히 엉성한 데 그 이유는 여전히 5번째 사람의 가장 높은 조상이 1이 아닌 4로 남아 있기 때문이야.  

 그럼에도 불구하고 위 코드에는 전혀 문제가 없는 것이, 

 내가 5번 조상을 출력해보고자 print(find(5))를 실행하면 

node[5] = find(node[5])가 실행되고

find(4) → find(1)에서 1이 return 되니까 

node[5] = 1이 이루어진 이후에 return node[5]라서 

node 리스트도 [ none, 1, 1, 1, 1, 1]로 수정되고 출력값도 1로 잘 출력이 돼.

 즉 find 함수는 가장 높은 조상을 찾아서 출력해주는 것 뿐만 아니라, 찾아낸 가장 높은 조상으로 node 리스트를 수정해주는 역할도 하는거야! 

그래서 ## 부분의 코드를 까먹을 경우 

Union - Find 전체가 제대로 돌아가지 않기 때문에, 저 부분만큼은 외우는 것을 추천할게. 

1. 시간복잡도? 

 Union - Find 코드를 살펴보면 결국 시간 복잡도가 Find 함수에 의존하게 된다는 것을 알 수 있는데

 이 Find 함수가 정말 신기한 것이, 일단 가장 최악의 상황을 생각해보면 

 사람이 n명 있을 때 계속 거슬러 올라가야하는 상황이라서 O(n)이 아닌가? 라고 착각할 수 있지만 

 거슬러 올라가서 조상을 찾았다면 그 조상으로 node 리스트를 업데이트해주기 때문에

 Union - Find를 반복하다보면 Find 함수의 시간복잡도는 O(1)이 되고 

덕분에 정말 속 시원한 실행속도를 보여줘. 

 내 경험상 파이썬으로도 1초를 잘 안넘기더라고. 캬 

 글이 너무 길어지는 거 같아서 예제 코드는 따로 첨부하지 않았지만, 문제들도 한 두개 풀어보면 이해가 쉽게 될 거야. 
 추후 크루스칼 알고리즘 등을 다룰 때 기반이 되는 알고리즘이기도 하니, 코딩쪽으로 욕심이 있다면 꼭 공부해볼 것!