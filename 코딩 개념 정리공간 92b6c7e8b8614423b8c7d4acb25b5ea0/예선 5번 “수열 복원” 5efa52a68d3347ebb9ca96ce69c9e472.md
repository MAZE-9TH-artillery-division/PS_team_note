# 예선 5번. “수열 복원”

< 문제 > 

 양의 정수로 이루어진 수열 a_1 , a_2 , … , a_n 이 있습니다. 

![1.JPG](%E1%84%8B%E1%85%A8%E1%84%89%E1%85%A5%E1%86%AB%205%E1%84%87%E1%85%A5%E1%86%AB%20%E2%80%9C%E1%84%89%E1%85%AE%E1%84%8B%E1%85%A7%E1%86%AF%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8B%E1%85%AF%E1%86%AB%E2%80%9D%205efa52a68d3347ebb9ca96ce69c9e472/1.jpg)

 이 수열에서 각 원소를 선택하거나 선택하지 않음으로써 총 2^n 개의 부분 수열을 만들 수 있고, 

만들어진 모든 부분 수열의 합인 2^n 개의 정수가 주어졌을 때, 원래의 수열 a_1 , a_2 , … , a_n을 

구하는 프로그램을 작성하세요. 

< 입력 > 

- 첫째 줄에 정수 N 이 주어집니다. ( 1 ≤ N ≤ 15 )
- 둘째 줄에 이 수열에서 만들 수 있는 모든 부분 수열의 합인 2^n 개의 정수

      s_1 , s_2 , … , s_(2^n) 이 주어집니다. 

![2.JPG](%E1%84%8B%E1%85%A8%E1%84%89%E1%85%A5%E1%86%AB%205%E1%84%87%E1%85%A5%E1%86%AB%20%E2%80%9C%E1%84%89%E1%85%AE%E1%84%8B%E1%85%A7%E1%86%AF%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8B%E1%85%AF%E1%86%AB%E2%80%9D%205efa52a68d3347ebb9ca96ce69c9e472/2.jpg)

< 출력 > 

- 첫째 줄에 원래 수열의 원소를 오름차순으로 출력합니다.

< 입력 예시 > 

3

1 4 7 3 0 6 5 2

< 출력 예시 > 

1 2 4

< 해설 > 

 우선 주어진 문제를 이해하는 것부터 시작하자. 

출력 예시의 1 2 4 수열이 주어졌다고 했을 때, 만들 수 있는 부분 수열들은 아래와 같아. 

“” (아무것도 고르지 않은 경우) 

“1” , “2” , “4”

“1 2” , “1 4” , “2 4” 

“1 2 4” 

각각의 합을 구해보면… 

0

1 2 4 

3 5 6

7

 이런 식으로 부분 수열의 합은  ( 중복을 포함하면 ) 모두 2^n개가 나타나. 

( n개의 숫자들을 각각 고르는 경우 / 고르지 않는 경우 ) 

 즉 이 문제는 반대로 가능한 합이 중복을 포함해서 모두 주어졌을 때, 원래 수열이 무엇이었을지

추측해야 하는 문제라고 할 수 있지. 

이때, 다음과 같은 생각을 해볼 수 있어. 

“어차피 오름차순으로 출력할 거면, 처음부터 원본 수열이 증가 수열이라고 가정하면 되지 않나?” 

그리고 위의 생각이, 내 풀이에서 상당히 요긴하게 사용되는 아이디어였어. 

 우선 편의상 길이가 4인 원본 수열을 구해야 한다고 하자. 아직 우리는 복원하는 방법을 모르니까, 

문제를 이해할 때처럼 한 번 가능한 부분 수열의 합을 쭉 나열해보자고. 

![3.jpg](%E1%84%8B%E1%85%A8%E1%84%89%E1%85%A5%E1%86%AB%205%E1%84%87%E1%85%A5%E1%86%AB%20%E2%80%9C%E1%84%89%E1%85%AE%E1%84%8B%E1%85%A7%E1%86%AF%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8B%E1%85%AF%E1%86%AB%E2%80%9D%205efa52a68d3347ebb9ca96ce69c9e472/3.jpg)

 어차피 0은 의미가 없으니까 생략하고, 남은 숫자들을 작은 것부터 나열해보자. 

그럼 a_1과 a_2는 항상 첫 번째와 두 번째에 온다는 것을 알 수가 있어. 그럼 a_3은 어떨까? 

아쉽지만 a_3의 순서는 확정 지을 수가 없어. a_1 + a_2 가 클지 a_3이 클지 당장은 알 수 없거든. 

 예시 : a_1 = 3 , a_2 = 4 , a_3 = 5면 a_1 + a_2 > a_3. 

그러나 a_1 = 1 , a_2 = 2 , a_3 = 4면 a_1 + a_2 < a_3. 

 그런데 잘 생각해보면, 이미 a_1과 a_2를 알고 있으니까 주어진 숫자가 a_1 + a_2 인지는

“계산을 통해” 알아낼 수 있어. 물론 a_1 + a_2 = a_3 이어서 같은 숫자가 연속으로 

두 개 주어질 수도 있긴 하겠지만, 어차피 a_1 + a_2로 만들어줄 수 있는 숫자라면

둘 중 하나는 신경 써줄 필요가 없겠지? 

 여기서 중요한 사실을 하나 알 수 있어. 

“이미 내가 확정한 숫자들로 만들어줄 수 있는 숫자가 들어오면, 걔는 무시하면 된다.”

 글로 읽기만 하면 이해가 잘 안 될 수 있으니 이 아이디어에 기반해서 원본 수열을 어떻게 얻어낼 수

있는지 실제 과정을 한 번 살펴보자. 

![4.jpg](%E1%84%8B%E1%85%A8%E1%84%89%E1%85%A5%E1%86%AB%205%E1%84%87%E1%85%A5%E1%86%AB%20%E2%80%9C%E1%84%89%E1%85%AE%E1%84%8B%E1%85%A7%E1%86%AF%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8B%E1%85%AF%E1%86%AB%E2%80%9D%205efa52a68d3347ebb9ca96ce69c9e472/4.jpg)

 우선 a_1 , a_2 까지 들고 있는 상태에서, 나에게 다음으로 들어올 수 있는 합은 

1. a_1 + a_2
2. a_3

둘  중 하나야. 근데 이미 a_1 + a_2는 만들어줄 수 있으니, 건너뛰어주면 되고 만들어줄 수 없는 

a_3은 정답으로서 가져가면 되겠지? 

 이렇게 a_3까지 가져온 상태에서, 다음으로 들어올 수 있는 값은 

1. a_1 + a_3
2. a_4

 둘 중 하나야. 역시 둘 중 누가 클지는 모르지만, 이미 a_1과 a_3을 들고 있으니까 

a_1 + a_3 이 들어오면 그건 걸러줄 수 있어. 이후 a_4은 정답으로 추가해주자. 

Q. 이걸 계속 반복하면 되는건가? 

A. ㄴㄴ. 이미 숫자 4개를 정답으로 모았으니까 이 이상으로는 반복할 필요가 없어. 

   곧바로 지금까지 모은 숫자 4개가 정답이라고 주장하면 돼. 

 뭔가 예선 4번에 비하면 간단하게 풀려서 찝찝한 거 같기도 하고…그치? 

근데 생각보다 구현은 쉽지 않아. 코드를 천천히 살펴보자. 

```python
n = int(input()) 
inform = list(map(int, input().split(' ')))
inform.sort() 

# 우리의 아이디어가 기본적으로
# 가능한 합들을 "작은 것부터" 나열했을 때 작동했기 때문에, 
# 들어온 입력을 정렬해줘야 해. 
 
count1 = [False for _ in range(inform[-1] + 1)] 
# 0부터 inform[-1]까지. 
# 어차피 inform[-1] = (모든 항을 다 합친 값)이니까 inform[-1]보다 큰 값이 나올 일은 없어. 
count1[0] = True 

count2 = [0 for _ in range(inform[-1] + 1)]
# 자 위의 두 count 배열이 내 코드의 핵심이야. 

# 만들 수 있는 모든 합들을 그때그때 필요할 때마다 계산하면
# 상당히 시간을 낭비하게 돼. 
# 내가 가지고 있는 숫자가 k개면 
# k C 2 = k * (k - 1) // 2 가지의 합이 가능한데, 
# 이걸 매번 계산하는 것은 결국 더 높은 시간 복잡도로 이어져. 

# 그러니 새로운 숫자를 정답에 추가해줄 때마다 
# "미리 계산해두고 써먹자" 

ans = [inform[1]] 
count1[inform[1]] = True 
# 실제로는 inform에 0도 있으니까 그걸 고려해주자. 

for i in range(2, len(inform), 1): 
	if(len(ans) == n): # 원본 수열을 다 구했다면 탈출. 
		break
		
	if(count2[inform[i]] == 0): 
		# 여기 조건을 count1[inform[i]] = False로 적지 않도록 조심해야 해. 
		# 예를 들어 주어진 inform이 0 1 2 3 3 이었다면 
		# 두 번째로 들어오는 3은 원본 수열의 원소라고 취급해주어야 하는데, 
		# 이를 단순히 count1[inform[i]] = True 여부로 판단하면 
		# 여러 번 들어오는 숫자에 대한 판단을 해줄 수 없어. 
		
		ans.append(inform[i]) 
		for j in range(inform[-1], -1, -1):
		# 새로운 숫자가 들어왔으니 
		# 만들 수 있는 숫자들을 기록해주자.  
			if(count1[j] == True): 
				count1[j + inform[i]] = True 
				count2[j + inform[i]] += 1 
				# 만들 수 있다고 기록 + 만들었으니 개수 1 추가.
				 
		count2[inform[i]] -= 1 # 이거 빼먹지 않도록 주의! 
		# inform[i] 자체는 만들자마자 사용한 셈이니 사용 가능한 개수를 하나 줄여줘야 해! 
		
	else: # 새로운 숫자가 들어왔는데 만들어줄 수 있는 숫자여서 무시 가능. 
		count2[inform[i]] -= 1 

# 정답 출력. 
for i in ans: 
	print(i, end = " ") 
```

( 이해가 안되는 부분이 있다면 댓글 또는 카톡으로 말해주세용 )