# 다익스트라 (Dijkstra) 알고리즘

- 관련 백준 문제 :
[1916번: 최소비용 구하기 (acmicpc.net)](https://www.acmicpc.net/problem/1916) ( 골드 5 ) 
[4485번: 녹색 옷 입은 애가 젤다지? (acmicpc.net)](https://www.acmicpc.net/problem/4485) ( 골드 4 )

** 언제 사용할 수 있는 알고리즘인가? 

1. 그래프의 “한 node”에서 “다른 모든 node”로의 최단 거리를 구할 때
—> 벨만-포드 알고리즘과 상황이 동일함. 
2. 그래프의 가중치들이 모두 “0 이상”일 때. 
—> 이 조건이 없으면 사용할 수 없음. 그 이유는 증명 과정 참고.

 *** 그래서 구현은 어떻게 하는가? ( 이론편 ) 

 다익스트라 알고리즘은 아래의 보조 정리에 기반해서 작동하는 알고리즘이야. 

Lemma. 

 두 정점 u와 v를 잇는 최단 경로를 하나 생각하자. 그 경로를 구성하는 부분 경로들 역시 그 자체로
최단 경로여야 한다. 

proof )  (귀류법) 

 u와 v를 잇는 최단 경로가, 자기 자신을 제외한 부분 경로를 갖지 않는다면 증명할 것이 없다. 

그러니 u와 v를 잇는 최단 경로가 자기 자신을 제외한 부분 경로 L을 갖고, L의 출발점과 

도착점을 각각 p, q라 하자. 

—> 모순을 위해 그 경로가 p와 q를 잇는 최단 경로가 아니라고 하자. 그럼 p와 q를 잇는 

     또 다른 경로 L’이 존재해서 L’의 비용이 L보다 작아야 한다. 

—> 그러면 u와 v를 잇는 최단 경로에서 L을 L’으로 대체함으로써 비용이 더 작은, 

      u와 v를 잇는 경로를 얻을 수 있는데 이는 우리가 맨 처음에 생각한 경로가 

      u와 v의 “최단”경로임에 모순이다. 

그러므로 귀류법에 의해, 최단 경로의 임의의 부분 경로는 역시 그 자체로 최단경로여야 한다. 

 위 정리를 알고 나면, 반대로 다음과 같은 생각도 해볼 수 있어. 

Q. 그러면 반대로 최단 경로들을 합쳐서 새로운 최단 경로를 만들 수도 있나? 

A. 어…근데 그게 약간 애매해. 아래 예시를 보자. 

![1.jpg](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%A1%20(Dijkstra)%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%202b11c63169d24221b3ffda4552139e1d/1.jpg)

 위 그림에서, “1번 노드 → 3번 노드”의 최단 경로를 구한다고 하자. 

1번 노드에서 출발할 때에는 “1번 노드 → 3번 노드” 경로를 택하는 것이 이득인 것처럼 보이지만, 

실제로는 “1번 노드 —> 2번 노드 —> 3번 노드”가 이득이야. ( 9 - 7 = 2 이므로 ) 

Q. 엥 그러면 걍 모든 간선들을 살펴보면 되는 거 아님? 

A. 맞긴 한데 그러면 시간이 오래 걸리겠지? 이때 Dijkstra 알고리즘은 아래의 전략을 선택해. 

”모든 가중치가 0 이상이라면, 지금 내가 보는 최단 경로가 실제로도 최단 경로이다.” 

뭔 소리냐면, 위 그림에서 가중치 -7을 0으로 고쳐볼게. 

가중치가 음수일 때 생기는 문제는 뭐였냐면, 

”당장은 최단 경로가 아닌 것처럼 보여도, 나중에는 최단 경로일 수도 있다.” 라는 점이었어. 

그런데 모든 가중치가 0 이상이면, 1번 노드에서 2번 노드로 이동한 순간 

3번 노드로 가기 위해 필요한 비용은 못해도 9 이상임이 보장돼. 

이미 1번 노드에서 2번 노드로 이동하기 위한 비용이 9이고, 이후의 추가 비용이 아무리 작아봐야 

0 이상일 테니까 ㅇㅇ. 

이정도면 이론적 배경은 충분하고, 아직 와닿지 않는다면 코드 구현 과정을 보면서 이해해보자. 

*** 그래서 구현은 어떻게 하는가? ( 코드편 ) 

 위 그림보다 조금 더 복잡한 예시를 살펴보자. 

![2.jpg](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%A1%20(Dijkstra)%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%202b11c63169d24221b3ffda4552139e1d/2.jpg)

 목표: 1번 노드에서 4번 노드로 가기 위해 필요한 최소 거리 (비용)

우선 아래처럼 1번 노드에서 각 점으로의 최소 거리를 저장해주는 배열과 방문여부 배열을 만들어. 

```python
dist = [float('inf'), 0, float('inf'), float('inf'), float('inf'), float('inf')] 
visited = [False for _ in range(n + 1)] 

# 자기 자신은 거리를 0으로 두고, 나머지는 전부 무한대로. 
# C언어의 경우에는, 문제 상황에서 절대로 나올 수 없는 매우 큰 값을 대신 저장해주면 돼. 
```

 그리고 문제에서 주는 입력을 참고해서 간선의 정보를 저장해야 하는데, 

보통은 인접 리스트 형식으로 저장할 수 있게 입력을 주는 편이야. 

* 인접 리스트 ( Adjacency list ) : 

 각 점마다 “그 점에서 갈 수 있는 다른 점”을 저장해주는 리스트. 자세한 건 아래 코드 참고. 

```python
edge = [[] for _ in range(n + 1)] 

edge[1] = [(2, 9), (3, 3), (5, 4)] # 도착점, 비용의 형태로 저장. 
edge[2] = [(1, 9), (3, 2), (4, 1)] 
edge[3] = [(1, 3), (2, 2), (4, 5)] 
edge[4] = [(2, 1), (3, 5), (5, 3)]
edge[5] = [(1, 4), (4, 3)] 
```

 

 여기까지 하면 필요한 전처리는 끝났고, 본격적으로 최단 거리를 구해보자. 

최단 거리는 아래의 과정을 통해서 구해. 

1. 일단 출발점인 1번 점에서, 갈 수 있는 점들의 최단 거리를 갱신해준다. 

 → 그러면 dist = [ float(’inf’) , 0, 9, 3, float(’inf’), 4 ] 가 되겠지? 

2. 그렇게 갱신된 점들 중에서, 최단 거리가 가장 작은 것을 고른다. 

 → 위 예시에서는 3번 노드를 고르게 되는데, 이론편에서 다뤘던 내용에 의해 

    3번 노드로 가는 다른 최단 경로는 존재하지 않아. 

   그러니 이제는 다시 3번 노드를 이용해서 다른 노드로의 최단 거리를 갱신해주는 거지. 

→ dist = [ float(’inf’), 0, 5, 3, 8, 4] 

   ( 2번 노드의 경우 1 → 2 보다 1 → 3 → 2 의 비용이 더 적기 때문에 갱신이 이루어져! ) 

 위의 과정을 반복하고 나면 1번 노드에서 2, 3, 4, 5번 노드로 가기 위해 필요한 최소 비용들이 

모두 구해져 있겠지? 이렇게 최단 거리를 구하는 알고리즘이 다익스트라 알고리즘이야. 

Q. 다 좋은데… 최단 거리가 가장 작은 걸 고르는 과정은 어떻게 구현을 하죠..? 

A. 그 과정을 어떻게 구현하냐에 따라서 이 알고리즘의 시간 복잡도가 달라져. 

   이 글에서는 우선 순위 큐로 최적화를 한 다익스트라 알고리즘을 다룰 거야. 

```python
from heapq import heappush, heappop 
# 모듈을 사용하든, 직접 클래스 등으로 구현하든 상관없어! 
# 적당한 우선순위 큐만 있으면 ok. 

queue = [(0, 1)]
# queue에는 우선 시작점에 대한 정보를 넣어. 
# 파이썬 heapq의 경우 순서쌍을 넣으면 첫 번째 성분을 기준으로 오름차순 정렬을 하기에
# (거리, 점 번호) 형식으로 넣어줘. 

while(queue): 
	d, node = heappop(queue) 
	if(visited[node]): #이미 최단 거리를 계산했다면 스킵.  
		continue 
	visited[node] = True 
	
	# 실제로 여기서 꺼내지는 d는 1번 노드에서 node번 노드로 가기 위한 최소 거리 
	# 또한 어떤 node가 꺼내진다는 것은 더 이상 다른 최단 거리가 존재하지 않는다는 것. 
	# ( 이해가 안된다면 아래 코드와 위의 설명을 다시 천천히 읽어보자. ) 
	
	for i in edge[node]: 
		nx, w = i # 다음 노드 번호, 비용 
		if(visited[nx] == False and d + w < dist[nx]): 
			# 현재 기록해놓은 nx 까지의 최단 거리보다 
			# 지금 노드를 거쳐서 가는 거리가 더 짧다면 갱신해주자. 
			dist[nx] = d + w 
			heappush(queue, (d + w, nx)) 
			# 갱신을 했다면 queue에 넣어주자. 
			# 이때, 거리 기준으로 오름차순 정렬이 되므로
			# queue에서 꺼내오는 (거리 값, 노드 번호)는 
			# 거리 값이 작은 것부터 꺼내져! 

```

 이제까지 다룬 내용을 기반으로 [1916번: 최소비용 구하기 (acmicpc.net)](https://www.acmicpc.net/problem/1916) 해결 코드를 작성하면

아래와 같아. 

```python
from heapq import heappush, heappop 
import sys 
input = sys.stdin.readline 

n, m = int(input()), int(input()) 

edge = [[] for _ in range(n + 1)] # 노드 번호는 1번부터 n번까지. 
for _ in range(m): 
    s, e, w = map(int, input().split(' ')) 
    # 출발 도시 / 도착 도시 / 비용 
    edge[s].append((e, w)) 

start, finish = map(int, input().split(' ')) 
# 실제로 우리가 최단 거리를 구해야 하는 출발 도시, 도착 도시 

dist = [float('inf') for _ in range(n + 1)]
visited = [False for _ in range(n + 1)]

dist[start] = 0 
queue = [(0, start)] 
while(queue): 
    d, node = heappop(queue) 
    if(visited[node]): 
        continue 
    elif(node == finish): 
        print(d) 
        break 
    visited[node] = True 

    for i in edge[node]: 
        nx, w = i 
        if(not visited[nx] and d + w < dist[nx]): 
            dist[nx] = d + w 
            heappush(queue, (d + w, nx)) 

```

 참고로 여기서 다루는 다익스트라 방식은, “최단 거리를 갱신해줄 수 있으면” 일단 queue에 

넣어주는 방식이기 때문에 위처럼 우리가 실제로 원하는 도착점에 대한 정보를 얻었으면 

바로 break를 걸어주는 것이 좋아. ( 안그러면 탐색할 필요가 없음에도 불구하고 계속 탐색하거든..)

(+ 실제로 break를 안 걸어주면 시간 초과야!)